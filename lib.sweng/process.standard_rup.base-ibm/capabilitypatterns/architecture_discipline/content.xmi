<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1">
  <org.eclipse.epf.uma:ProcessDescription xmi:id="-kDBIBFrxkS93rEC0VfiZOw" name="architecture_discipline,_PDHikSsEEd-5jezL08ZExg" guid="-kDBIBFrxkS93rEC0VfiZOw" version="7.5.0"/>
  <org.eclipse.epf.uma:ActivityDescription xmi:id="-P5IAU07zk2hl4DTuBqSoKQ" name="refine_the_architecture,{F2160C54-F666-4736-9982-FC7F58F15FAD}" guid="-P5IAU07zk2hl4DTuBqSoKQ">
    <mainDescription>&lt;a id=&quot;Description&quot; name=&quot;Description&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    This activity:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Provides the natural &lt;b>transition from analysis&lt;/b> activities &lt;b>to design&lt;/b> activities, identifying: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                appropriate design elements from analysis elements&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                appropriate design mechanisms from related analysis mechanisms&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Describes&lt;/b> the organization of the system's &lt;b>run-time and deployment architecture&lt;/b>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Organizes the implementation model&lt;/b> so as to make the transition between design and implementation seamless&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Maintains the consistency and integrity of the architecture&lt;/b>, ensuring that: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                new design elements identified for the current iteration are integrated with pre-existing design elements.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                maximal re-use of available components and design elements is achieved as early as possible in the design&#xD;
                effort.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
    <usageGuidance>&lt;p>&#xD;
    The work is best done in several sessions, perhaps performed over a few days (or weeks and months for very large&#xD;
    systems). The initial focus will be on the&amp;nbsp;identification of&amp;nbsp;&lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.tech.common.extend_supp/guidances/concepts/design_mechanism_CE197B4E.html&quot;&#xD;
    guid=&quot;_w2ACwA4LEduibvKwrGxWxA&quot;>Design Mechanism&lt;/a>s and&amp;nbsp;design elements, paying special attention&#xD;
    to&amp;nbsp;incorporating existing design elements to make sure that new elements do not duplicate functionality of&#xD;
    existing elements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As the design emerges, concurrency and distribution issues are introduced in the activities to describe the run-time&#xD;
    architecture and to describe distribution, respectively. As these issues are considered, changes to design elements may&#xD;
    be required to split behavior across processes, threads or nodes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As the individual models are refined to incorporate the architectural decisions, the results are documented in&#xD;
    respective view sections in the Software Architecture Document (e.g., as the Design Model is refined, the Logical View&#xD;
    of the Software Architecture Document is refined, as well). The resulting architecture is reviewed.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></usageGuidance>
    <howtoStaff>&lt;a id=&quot;HowToStaff&quot; name=&quot;HowToStaff&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    These activities are best carried out by a small team staffed by cross-functional team members. Issues that are&#xD;
    typically architecturally significant include usability, performance, scaling, process and thread synchronization, and&#xD;
    distribution. The team should also include members with domain experience who can identify key abstractions. The team&#xD;
    should also have experience with model organization and layering. The team will need to be able to pull all these&#xD;
    disparate threads into a cohesive, coherent (albeit preliminary) architecture.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Because the focus of the architecture effort is shifting toward implementation issues, greater attention needs to be&#xD;
    paid to specific technology issues. This will force the architecture team to shift members or expand to include people&#xD;
    with distribution and deployment expertise (if those issues are architecturally significant). In order to understand&#xD;
    the potential impact of the structure on the implementation model on the ease of integration, expertise in the software&#xD;
    build management process is useful to have.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    At the same time, it is essential that the architecture team not be composed of a large extended team. A strategy for&#xD;
    countering this trend is to retain a relatively small core team with a satellite group of extended team members that&#xD;
    are brought in as &quot;consultants&quot; on key issues&lt;b>.&lt;/b> This structure also works well for smaller projects where&#xD;
    specific expertise may be borrowed or contracted from other organizations; they can be brought in as specific issues&#xD;
    need to be addressed.&#xD;
&lt;/p></howtoStaff>
  </org.eclipse.epf.uma:ActivityDescription>
  <org.eclipse.epf.uma:ActivityDescription xmi:id="-UblDFfEDZ8OaATNIlgmY6g" name="define_a_candidate_architecture,{71ADFE9A-34A0-41BD-8A17-BEA3210E2BBD}" guid="-UblDFfEDZ8OaATNIlgmY6g">
    <mainDescription>&lt;a id=&quot;Description&quot; name=&quot;Description&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    This activity has the following goals:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Create an initial sketch of the architecture of the system &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Define an initial set of architecturally significant elements to use as the basis for analysis&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Define an initial set of analysis mechanisms&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Define the initial layering and organization of the system&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Define the use-case realizations to be addressed in the current iteration&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Identify analysis classes from the architecturally significant use cases&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Update the use-case realizations with analysis class interactions&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
    <usageGuidance>&lt;p>&#xD;
    The work is best done in several sessions, perhaps performed over a few days (or weeks and months for very large&#xD;
    systems), with iteration between architectural analysis and use-case analysis. Perform an initial pass at the&#xD;
    architecture in while doing architectural analysis, then choose architecturally significant use cases, performing&#xD;
    use-case analysis on each one. After (or as) each use case is analyzed, update the architecture as needed to reflect&#xD;
    adaptations required to accommodate new behavior of the system and to address potential architectural problems which&#xD;
    are identified.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Where the architecture already exists (either from a prior project or iteration), change requests may need to be&#xD;
    created to change the architecture to account for the new behavior the system must support. These changes may be to any&#xD;
    artifact in the process, depending on the scope of the change.&#xD;
&lt;/p></usageGuidance>
    <howtoStaff>&lt;a id=&quot;HowToStaff&quot; name=&quot;HowToStaff&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    The activity to define a candidate architecture is&amp;nbsp;best carried out by a small team staffed by cross-functional&#xD;
    team members. Issues that are typically architecturally significant include performance, scaling, process and thread&#xD;
    synchronization, and distribution. The team should also include members with domain experience who can identify key&#xD;
    abstractions. The team should also have experience with model organization and layering. From these inputs, the team&#xD;
    will need to be able to synthesize a model, or even a prototype, of a solution.&#xD;
&lt;/p></howtoStaff>
  </org.eclipse.epf.uma:ActivityDescription>
  <org.eclipse.epf.uma:ActivityDescription xmi:id="-YVuMWlERMYFr1hhtq_y4og" name="analyze_behavior,{DAFB461E-9ADB-4849-8285-B7E3E72BDB43}" guid="-YVuMWlERMYFr1hhtq_y4og">
    <mainDescription>&lt;a id=&quot;Description&quot; name=&quot;Description&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    This activity occurs in each iteration in which there are behavioral requirements to be analyzed and designed.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The analysis of behavioral requirements includes the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        identifying analysis classes that satisfy the required behavior&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        determining how these analysis classes fit into the logical architecture (the major subsystems and classes) of the&#xD;
        system. The analysis classes may be determined to belong to existing subsystems, require the creation of new&#xD;
        subsystems, or cause existing subsystems and their interfaces to be redefined.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    This activity may also include modeling and prototyping of the user interface.&#xD;
&lt;/p></mainDescription>
    <usageGuidance>&lt;p>&#xD;
    Tasks to design and prototype the user-interface are performed iteratively throughout the Elaboration iterations. Early&#xD;
    iterations focus on the initial user interface design, which includes the identification and design of the key user&#xD;
    interface elements and the navigation paths between them. &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.tech.common.extend_supp-ibm/guidances/concepts/storyboarding_84E2BCE2.html&quot;&#xD;
    guid=&quot;_dP7AkHUyEd2KwLyf6ks5lg&quot;>Storyboarding&lt;/a> is an effective technique that can be used during user-interface&#xD;
    design to gain a better understanding of how the user interface should behave. Once consensus on the initial&#xD;
    user-interface design has been reached, then the development of an executable user-interface prototype begins. Feedback&#xD;
    on the prototype is fed back into the user-interface design (and possibly even the requirements). The initial prototype&#xD;
    typically supports only a subset of the system's features. In subsequent iterations, the prototype is expanded,&#xD;
    gradually adding broader coverage of the system's features. The main benefit of producing non-functional versions of&#xD;
    the user-interface during user-interface design is to postpone the investment of more elaborate and costly functional&#xD;
    user-interface prototypes until there is consensus on the overall user-interface design. It is important to work&#xD;
    closely with users and potential users of the system when designing and prototyping the user-interface in order to&#xD;
    confirm and validate the usability of the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A number of use-case analysis workshops may be organized in parallel, limited only by the available resource pool and&#xD;
    the skills of the participants. As soon as possible following each use-case analysis workshop, some members of the&#xD;
    workshop and some members of the architecture team should work to merge the results of the workshop in&#xD;
    the&amp;nbsp;identification of design elements. Members of both teams are essential: the use-case analysis team members&#xD;
    understand the context in which the analysis classes were identified, while the architecture team understands the&#xD;
    greater context of the design as well as other use cases which have already been identified.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As the design work matures and stabilizes, increasingly larger parts of it can and should be reviewed. Smaller, more&#xD;
    focused reviews are better than large all-encompassing reviews; eight two-hour reviews focused on very specific aspects&#xD;
    are significantly better than a single review spanning two days. In the focused reviews, define objectives to bound the&#xD;
    focus of the review, and ensure that a small review team with the right skills for the review, given the objectives, is&#xD;
    available for the review. Early reviews should focus primarily on the integrity of layering and packaging in the&#xD;
    design, the stability and quality of the interfaces, and the completeness of coverage of the use case behavior. Later&#xD;
    reviews should drill down into packages and subsystems to ensure that their contents completely and correctly realize&#xD;
    their defined interfaces, and that the dependencies and associations between design elements are necessary, sufficient&#xD;
    and correct. See the check-points on each design artifacts for specific review points.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></usageGuidance>
    <howtoStaff>&lt;p>&#xD;
    Especially in larger projects, user-interface design and prototyping is performed by a separate group of people,&#xD;
    focused only on usability of the system and the user interface. However, this group should work closely with other&#xD;
    members of the development team, especially those responsible for the requirements and the business logic, to make sure&#xD;
    that the user interface is what the user expects, and that the business logic provides what the user interface requires&#xD;
    (in terms of content and user actions).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The use-case analysis workshops&amp;nbsp;are best conducted by a small group with a blend of skills. The task to identify&#xD;
    design elements requires a broader perspective of the architecture and the results of other use-case analysis&#xD;
    workshops, and requires some experience in the implementation technology and any frameworks being used on the project.&#xD;
    Reviews should be staffed with people who have both in-depth knowledge of the implementation technologies as well as an&#xD;
    understanding of the problem domain.&#xD;
&lt;/p></howtoStaff>
  </org.eclipse.epf.uma:ActivityDescription>
  <org.eclipse.epf.uma:ActivityDescription xmi:id="-HKBMsnsxjGmOa05gSnRKvw" name="perform_architectural_synthesis,{C67C8E56-D9B6-499C-8171-C153FB28F1C3}" guid="-HKBMsnsxjGmOa05gSnRKvw">
    <mainDescription>&lt;a id=&quot;Description&quot; name=&quot;Description&quot;>&lt;/a> &lt;br />&#xD;
&lt;br /></mainDescription>
    <usageGuidance>&lt;p>&#xD;
    This work takes place during inception, and so should be limited to one or two iterations. The purpose is to determine&#xD;
    feasibility, not to construct the system during this workflow detail.&#xD;
&lt;/p>&lt;br /></usageGuidance>
    <howtoStaff>&lt;a id=&quot;HowToStaff&quot; name=&quot;HowToStaff&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    As with &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../process.standard_rup.base-ibm/capabilitypatterns/define_a_candidate_architecture_33E08AA9.html&quot;&#xD;
    guid=&quot;_8lPskNerEd-Zq9ImbgqLFQ&quot;>Activity: Define a Candidate Architecture&lt;/a>, this activity is best carried out by a&#xD;
    small team staffed by cross-functional team members. Issues that are typically architecturally significant include&#xD;
    performance, scaling, process and thread synchronization, and distribution. The team should also include members with&#xD;
    domain experience who can identify key abstractions. The team should also have experience with model organization and&#xD;
    layering. From these inputs, the team will need to be able to synthesize a model, or even a prototype, of a solution.&#xD;
&lt;/p></howtoStaff>
  </org.eclipse.epf.uma:ActivityDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-8iyX9cbnMWsxjYHlmuDadQ" name="document_architectural_decisions,_ZY7v1derEd-Zq9ImbgqLFQ" guid="-8iyX9cbnMWsxjYHlmuDadQ">
    <refinedDescription>&lt;p>&#xD;
    In this task, you state each architectural issue or problem, consider alternatives, make and document decisions, and&#xD;
    provide rationale for each decision.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.tech.common.extend_supp-ibm/guidances/guidelines/documenting_architectural_decisions_8EF0BD39.html&quot;&#xD;
    guid=&quot;_RtLzgIByEd2z9IawWqZSFw&quot;>Guideline: Documenting Architectural Decisions&lt;/a>&amp;nbsp;for more information.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-Zjp5RG-TO__QPBSREMrr7g" name="architectural_decisions,_ZY7v19erEd-Zq9ImbgqLFQ" guid="-Zjp5RG-TO__QPBSREMrr7g">
    <keyConsiderations>&lt;p>&#xD;
    Some important considerations for making and implementing architectural decisions:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Make sure the process for making decisions has the right level of sponsorship necessary to enforce those decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Make architecturally significant decisions early and be sure to validate high risk decisions using an executable&#xD;
        architecture&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Review and update architectural decisions as development progresses and update this artifact so it reflects any&#xD;
        changes to your decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        It is not necessary to document every minute decision you make when developing the architecture; focus on those&#xD;
        that are controversial or are based on reasoning that is not obvious&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact documents key architectural decisions and the rationale behind those decisions.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-9lNEwBlZ5Bmv9Ynhe4iwjQ" name="detail_component_model,_ZY7v2NerEd-Zq9ImbgqLFQ" guid="-9lNEwBlZ5Bmv9Ynhe4iwjQ">
    <refinedDescription>&lt;p>&#xD;
    In this task, you detail and structure the logical components, define their interfaces, and transform them into&#xD;
    physical components. You validate whether the component model addresses the architecturally significant requirements.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-91entNr6qSptS_MZCFc4rg" name="component_model,_ZY7v2derEd-Zq9ImbgqLFQ" guid="-91entNr6qSptS_MZCFc4rg">
    <keyConsiderations>&lt;p>&#xD;
    Points to consider when deciding whether to use a Component Model:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A Component Model is useful when you must design the system for multiple target environments, with separate design&#xD;
        architectures. The Component Model is an abstraction, or a generalization, of the system design. It omits most of&#xD;
        the details of the design in order to provide an overview of the system's functionality.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Component Model provides value when the design is complex, such that new team members need a simplified,&#xD;
        abstracted model to understand it. A well-defined architecture can serve the same purpose.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Balance the extra work required to ensure that the component and design models remain consistent against the&#xD;
        benefit of having a view of the system that represents only the most important details of how the system works. It&#xD;
        can be very costly to maintain a high degree of fidelity between the Component Model and the system design. A less&#xD;
        ambitious approach might be to maintain the Component Model with only the most important components and the key&#xD;
        abstractions in the design. As the complexity of the Component Model increases, so does the cost to maintain it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you no longer maintain the Component Model, its value decays rapidly. At some point, it no longer accurately&#xD;
        reflects the current functional design of the system. Deciding to no longer maintain the Component Model may be&#xD;
        appropriate, as it may have served its purpose, but the decision should be a conscious one.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models tend to be useful in companies where systems live for decades, or where there are many variants of the&#xD;
    system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To ensure the successful development of a component model on a project, your team should:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Create a stable and coherent structure&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Focus on the right levels of abstraction&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Develop relationship and interaction diagrams in parallel&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Select architecturally significant requirements as inputs to the Component Model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Plan how your team will leverage the Component Model throughout the project lifecycle&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    The component model describes the structure of a system in terms of its software components with their&#xD;
    responsibilities, interfaces, relationships, and the way they collaborate to deliver the required functionality. The&#xD;
    component model is the main artifact documenting the functional view of the architecture and serves as an abstraction&#xD;
    of the design. Components identified may be decomposed into further component models before they complete the&#xD;
    specification required for detailed design.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Component models help define and document:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The structure of the system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The recurring interactions and dependencies between sets of components&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The components present within an enterprise, each of which may be made up of smaller components.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models are documented at 2 levels:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The logical level - focuses on specifying the components' responsibilities and characteristics required to deliver&#xD;
        the requirements. These specifications are technology and product neutral.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The physical level -focuses on how to implement the components to meet the previously established specifications.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You may transform logical components into physical components via custom development, the purchase of products, or the&#xD;
    reuse of assets.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It may be important to maintain a separation between logical and physical components on larger projects. However,&#xD;
    smaller or less complex projects may evolve a single logical component model into a physical model, and end up with&#xD;
    only a physical model.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Examples of components at the logical level are a 'Message Bus' or a 'Customer Relationship Manager' component.&#xD;
    Components at the physical level that implement these logical components might be 'IBM WebSphere Message Broker' or&#xD;
    'Siebel Contact Center.'&lt;br />&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-Xgbygm5cpLWiZLkQwNNo_g" name="architecture_overview,_ZY7v2terEd-Zq9ImbgqLFQ" guid="-Xgbygm5cpLWiZLkQwNNo_g">
    <keyConsiderations>As communication is its main purpose, it is more important for the description of the architecture to be simple, brief,&#xD;
clear, and understandable than comprehensive or accurate in all details.</keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact provides an overview of the main conceptual elements and relationships of an architecture, which might&#xD;
    include candidate subsystems, components, nodes, connections, data stores, users and external systems. As such, it&#xD;
    represents the governing ideas and candidate building blocks of the architecture.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-mQktCUJUrjAYcGBAko309Q" name="component_specification,_ZY7v29erEd-Zq9ImbgqLFQ" guid="-mQktCUJUrjAYcGBAko309Q">
    <keyConsiderations>&lt;p>&#xD;
    Points to consider when deciding whether to use a Component Specification:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The Component Specification provides value when the architecture is complex, such that new team members need a&#xD;
        simplified, abstracted model to understand it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The extra work required to ensure that the Component Specification and Executable Architecture remain consistent&#xD;
        must be balanced against the benefit of having a view of the system that represents only the most important details&#xD;
        of how the system works. It can be very costly to maintain a high degree of fidelity between the Component&#xD;
        Specification and Executable Architecture. As the complexity of the Component Specification increases, so does the&#xD;
        cost to maintain it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you no longer maintain the Component Specification, its value decays rapidly. At some point, it will no longer&#xD;
        accurately reflect the Executable Architecture. Deciding to no longer maintain the Component Specification may be&#xD;
        appropriate (it may have served its purpose), but the decision should be a conscious one.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component Specifications tend to be useful in companies where systems live for decades, or where there are many&#xD;
    variants of the system.&lt;br />&#xD;
&lt;/p></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact specifies the details of a component identified in the Component Model. The specification shows the&#xD;
    interfaces offered and used by the component, identifies where business rules are placed, and details the operations&#xD;
    and their signatures for each interface.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Component Interfaces&lt;/strong> - An interface specifies one or more operation signatures and is both offered and&#xD;
    used by a component. Offering an interface means the component makes the interface available for other components to&#xD;
    use.&amp;nbsp;&amp;nbsp;Each interface provides a unique and well-defined set of operations. Hiding the structure of a&#xD;
    component and its data behind an interface allows that data to be changed without affecting how the interface is&#xD;
    used.&amp;nbsp; The actual composition of that data may change, but the interface that provides access to that data is&#xD;
    fixed. Interfaces also describe the state of a component.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Business Rules&lt;/strong> - Business Rules dictate the behavior of a system, and the component specification&#xD;
    defines how the system implements the business rules.&amp;nbsp; For example, a business rule may state that Internet&#xD;
    transactions for an on-line order can not exceed $1000 for a given account. A component that manages account&#xD;
    transactions may define an on-line transactions interface that implements this business rule.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Operations&lt;/strong> - Fully specified Component Specifications assign operations and operation signatures to&#xD;
    the interfaces and may define pre- and post-conditions on the operations.&amp;nbsp; Pre- and post-conditions specify the&#xD;
    effect of an operation without prescribing an algorithm or implementation.&amp;nbsp;A post-condition specifies the effect&#xD;
    of the operation on the components data or state.&amp;nbsp;A pre-condition is the condition under which the operation&#xD;
    guarantees that the post-condition is true.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-DHDpTro_GKV18-i7dlL-sw" name="detail_operational_model,_ZY7v3NerEd-Zq9ImbgqLFQ" guid="-DHDpTro_GKV18-i7dlL-sw">
    <keyConsiderations>The logical level of the operational model is developed in parallel with the physical operational model and is tightly&#xD;
coupled with both its development and also the development of the component model. Therefore decisions made when developing&#xD;
the logical operational model may result in changes to both the physical operational model and the component model.&lt;br />&#xD;
&lt;br />&#xD;
The state of the operational model which needs to be reached at the end of this task is dependent on the context in which&#xD;
it is being developed, the level of confidence that needs to be achieved in the architecture and design, and the degree of&#xD;
accuracy of estimates of resources to further develop the operational model.</keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    Detail the required operational characteristics and capabilities of the IT system architecture and&amp;nbsp;describe, at an&#xD;
    architectural level, the network of computer systems and their associated peripherals, together with the systems&#xD;
    software, middleware, and application software that they run in order to support the users of the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Use reference architectures as a source for specification when there is a good fit to the target problem domain.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-bRzTQpZNh94AJayFW-GqXA" name="operational_model,_ZY7v3derEd-Zq9ImbgqLFQ" guid="-bRzTQpZNh94AJayFW-GqXA">
    <keyConsiderations>&lt;h5>&#xD;
    Levels of this artifact&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The artifact can be a large and complex work product.&amp;nbsp; It is therefore important to understand how it may be best&#xD;
    developed and presented, depending on the particular context.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In order to reduce the complexity of the development process, the various development techniques available take&#xD;
    advantage of a number of well-defined views and levels of completeness.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Therefore this artifact can be refined and elaborated in various ways depending on the nature of the project life cycle&#xD;
    and the development techniques used.&amp;nbsp; Useful intermediate stages of development have been defined for both the&#xD;
    &lt;strong>logical&lt;/strong> and &lt;strong>physical&lt;/strong> levels of this artifact as described within this artifact.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Degree of completeness (elaboration) and quality (refinement)&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Individual circumstances will dictate the degree of completeness (including omission) of each level of this&#xD;
    artifact.&amp;nbsp; Decisions on level of detail, focus and completeness will be based on many factors, such as&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Audience (e.g. business people, IT Architects, or Developers)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Purpose (is it to be fully specified and configured or a generalized reference pattern?)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Completeness (is it early in a project's life, or a finished artifact?)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The degree of completeness reached (or required) will also be dependent on the development process (e.g. waterfall,&#xD;
    iterative, etc.).&amp;nbsp; The levels of this artifact elaborate through degrees of completeness towards their completed&#xD;
    states while remaining synchronized and consistent with one another at each major project &quot;milestone&quot;.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Varying depth of detail&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    As well describing the operational aspect of a complete IT system, it is often helpful to develop this artifact showing&#xD;
    greater detail for particular parts of the system.&amp;nbsp; For example:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        This artifact may model a whole IT system as one or two nodes on the overall model, but a further more detailed&#xD;
        representation of parts of the IT system in a particular location may also be constructed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        This artifact may model a single part of an IT system in detail without modeling the whole IT system.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        This artifact may include the same &quot;recurring pattern&quot; of nodes and/or connections, and, in this case, a separate&#xD;
        artifact may detail the recurring pattern and be referenced by the main artifact.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h5>&#xD;
    Cross-cutting viewpoints&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    This artifact and the logical and physical levels of this artifact may be the focus of a particular viewpoint, at any&#xD;
    degree of elaboration and refinement, to address the concerns of a particular stakeholder. These cross-cutting&#xD;
    viewpoints overlap with one another.&amp;nbsp; For example, views may be constructed on this artifact for the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Application&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Technical&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Performance&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Capacity&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Availability and Recovery&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Security and Privacy Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Operability and Operations Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Systems Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Software Distribution and Installation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Distributed Data Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Problem Identification and Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        End User Support/Helpdesk&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Networking&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Accessibility&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        National Language Support&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Financial proprietary&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Archiving&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Such filtering does not generally change the elements in the artifact rather it simply enables a clearer focus on some&#xD;
    particular part of it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Please refer to &quot;An Introduction to the IBM Views and Viewpoints Framework for IT Systems&quot; Whitepaper for further&#xD;
    details on the views and viewpoints framework including the relationship between base and cross-cutting views.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Linkages to other work products&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    As well as a linkage via Deployment Units with the functional aspect of architecture as embodied in the Component&#xD;
    Model, this artifact has influences and/or is strongly interdependent on other areas that cover the design of the&#xD;
    infrastructure that will implement the operational aspect of architecture. For example:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Network Design: affects the application design, middleware selection, component placement, security and privacy,&#xD;
        systems management and overall operational system control.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Platform Design; the detailed design and configuration of the platforms that will implement the nodes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Storage Design; the detailed design and configuration of storage which may be shared across multiple platforms.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Site &amp;amp; Facilities Design; the detailed design and configuration of the site and facilities in the locations in&#xD;
        which nodes (implemented by platforms) are placed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Systems Management design; through its definition of how the IT system is spread out over locations and what&#xD;
        systems management components and nodes are needed at each location.&amp;nbsp; Selection of a systems management style&#xD;
        is an important decision, which determines: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                The cost of operations management&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                The cost of software distribution&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                The complexity of system management tooling&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Potential security and performance of the IT system (ability to satisfy the service level requirements)&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Existing or planned enterprise-wide IT infrastructure initiatives on which the target system will be&#xD;
        implemented.&amp;nbsp; For example, enterprise wide middleware decisions may well move function, which would otherwise&#xD;
        be duplicated across multiple applications, into a set of shared services, which are usually purchased or part of&#xD;
        an enterprise wide development effort.&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact describes the operational distribution of a system's components (which may be grouped into deployment&#xD;
    units) onto nodes, the placement of nodes and users across locations, the connections between nodes necessary to&#xD;
    support the required interactions between components, in order to achieve the system's functional and non-functional&#xD;
    requirements within the constraints of technology, skills and budget.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Operational Modeling Terminology&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    This artifact's (and that of its contained artifacts) terminology is defined within the System Description Standard R3&#xD;
    Semantic Specification (see Guidance for link) which includes definitions for the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Actors (and workers) - the roles a user or an external system play with respect to the target system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Locations - a geographical area or position.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Borders - representing the existing connection between two locations&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Components - modular units of functionality, which make this functionality available through an interface.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Deployment Units - a grouping of facets of a component that have similar characteristics.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Connectors - enable the exchange of messages (interactions) between resource containers.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Interactions - identify the messages exchanged between one or two resource containers in the context of a&#xD;
        collaboration, and the sequencing of these messages via their associated send/receive events.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Nodes - a collection of components fulfilling a specific responsibility with a certain quality of service within&#xD;
        the target system.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Connections - supports the required connectivity between connectable model elements.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Zones - an aggregation of a number of model elements with a common (sub-) set of values for a particular&#xD;
        non-functional requirement and/or non-functional characteristic.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Boundaries - associated with a change in value for a particular non-functional requirement and/or characteristic&#xD;
        between two model elements.&amp;nbsp;&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Depending on the development approach adopted and/or the context, it can be very helpful to create levels of this&#xD;
    artifact.&amp;nbsp; The two basic levels of this artifact are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Logical&lt;/strong>:&amp;nbsp; This level describes the characteristics and capabilities of the operational aspect&#xD;
        of the system architecture in a &lt;strong>technology independent and product neutral&lt;/strong> manner.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Physical&lt;/strong>:&amp;nbsp; This level describes characteristics and capabilities of the operational aspect of&#xD;
        the system architecture in a &lt;strong>technology and product dependent&lt;/strong> manner.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Both levels of this artifact may be further described at three different sub-levels relating to the degree to which the&#xD;
    level has been sized:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Unsized&lt;/strong> (or unranged) - the technology and products are specified to support the components&#xD;
        deployed but not sized and without detailing how the system will achieve the service level characteristics.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Ranged&lt;/strong> - the technology and products are specified to support a bounded range of requirements for&#xD;
        a defined range of circumstances.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Sized&lt;/strong> - the technology and products are specified and sized to support the components deployed and&#xD;
        details how the system will achieve the service level characteristics.&#xD;
    &lt;/li>&#xD;
&lt;/ul></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-Vw_K5sTK-dTz7qTEu6VeYQ" name="document_architectural_decisions,_8lPsk9erEd-Zq9ImbgqLFQ" guid="-Vw_K5sTK-dTz7qTEu6VeYQ">
    <refinedDescription>&lt;p>&#xD;
    In this task, you state each architectural issue or problem, consider alternatives, make and document decisions, and&#xD;
    provide rationale for each decision.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.tech.common.extend_supp-ibm/guidances/guidelines/documenting_architectural_decisions_8EF0BD39.html&quot;&#xD;
    guid=&quot;_RtLzgIByEd2z9IawWqZSFw&quot;>Guideline: Documenting Architectural Decisions&lt;/a>&amp;nbsp;for more information.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-aeMDvSmqcD-CFBbi1WCYJw" name="architectural_decisions,_8lPslderEd-Zq9ImbgqLFQ" guid="-aeMDvSmqcD-CFBbi1WCYJw">
    <keyConsiderations>&lt;p>&#xD;
    Some important considerations for making and implementing architectural decisions:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Make sure the process for making decisions has the right level of sponsorship necessary to enforce those decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Make architecturally significant decisions early and be sure to validate high risk decisions using an executable&#xD;
        architecture&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Review and update architectural decisions as development progresses and update this artifact so it reflects any&#xD;
        changes to your decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        It is not necessary to document every minute decision you make when developing the architecture; focus on those&#xD;
        that are controversial or are based on reasoning that is not obvious&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact documents key architectural decisions and the rationale behind those decisions.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-DZ_dzUnCl3mOk8fQitzYnA" name="outline_component_model,_8lPslterEd-Zq9ImbgqLFQ" guid="-DZ_dzUnCl3mOk8fQitzYnA">
    <refinedDescription>In this task, you identify the most obvious candidates for logical components, and define some initial, high-level&#xD;
collaborations between these components. You define key responsibilities for each component, and validate that your&#xD;
architecture is on the right track. During this task, you make key decisions that affect the architecture, and then&#xD;
document them.</refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-51olQ9s8xHWwUjkhuPK6bQ" name="architecture_overview,_8lPsl9erEd-Zq9ImbgqLFQ" guid="-51olQ9s8xHWwUjkhuPK6bQ">
    <keyConsiderations>As communication is its main purpose, it is more important for the description of the architecture to be simple, brief,&#xD;
clear, and understandable than comprehensive or accurate in all details.</keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact provides an overview of the main conceptual elements and relationships of an architecture, which might&#xD;
    include candidate subsystems, components, nodes, connections, data stores, users and external systems. As such, it&#xD;
    represents the governing ideas and candidate building blocks of the architecture.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-G1-lHmRuT6gkUAivK7nGVw" name="component_model,_8lPsmNerEd-Zq9ImbgqLFQ" guid="-G1-lHmRuT6gkUAivK7nGVw">
    <keyConsiderations>&lt;p>&#xD;
    Points to consider when deciding whether to use a Component Model:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A Component Model is useful when you must design the system for multiple target environments, with separate design&#xD;
        architectures. The Component Model is an abstraction, or a generalization, of the system design. It omits most of&#xD;
        the details of the design in order to provide an overview of the system's functionality.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Component Model provides value when the design is complex, such that new team members need a simplified,&#xD;
        abstracted model to understand it. A well-defined architecture can serve the same purpose.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Balance the extra work required to ensure that the component and design models remain consistent against the&#xD;
        benefit of having a view of the system that represents only the most important details of how the system works. It&#xD;
        can be very costly to maintain a high degree of fidelity between the Component Model and the system design. A less&#xD;
        ambitious approach might be to maintain the Component Model with only the most important components and the key&#xD;
        abstractions in the design. As the complexity of the Component Model increases, so does the cost to maintain it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you no longer maintain the Component Model, its value decays rapidly. At some point, it no longer accurately&#xD;
        reflects the current functional design of the system. Deciding to no longer maintain the Component Model may be&#xD;
        appropriate, as it may have served its purpose, but the decision should be a conscious one.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models tend to be useful in companies where systems live for decades, or where there are many variants of the&#xD;
    system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To ensure the successful development of a component model on a project, your team should:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Create a stable and coherent structure&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Focus on the right levels of abstraction&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Develop relationship and interaction diagrams in parallel&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Select architecturally significant requirements as inputs to the Component Model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Plan how your team will leverage the Component Model throughout the project lifecycle&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    The component model describes the structure of a system in terms of its software components with their&#xD;
    responsibilities, interfaces, relationships, and the way they collaborate to deliver the required functionality. The&#xD;
    component model is the main artifact documenting the functional view of the architecture and serves as an abstraction&#xD;
    of the design. Components identified may be decomposed into further component models before they complete the&#xD;
    specification required for detailed design.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Component models help define and document:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The structure of the system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The recurring interactions and dependencies between sets of components&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The components present within an enterprise, each of which may be made up of smaller components.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models are documented at 2 levels:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The logical level - focuses on specifying the components' responsibilities and characteristics required to deliver&#xD;
        the requirements. These specifications are technology and product neutral.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The physical level -focuses on how to implement the components to meet the previously established specifications.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You may transform logical components into physical components via custom development, the purchase of products, or the&#xD;
    reuse of assets.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It may be important to maintain a separation between logical and physical components on larger projects. However,&#xD;
    smaller or less complex projects may evolve a single logical component model into a physical model, and end up with&#xD;
    only a physical model.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Examples of components at the logical level are a 'Message Bus' or a 'Customer Relationship Manager' component.&#xD;
    Components at the physical level that implement these logical components might be 'IBM WebSphere Message Broker' or&#xD;
    'Siebel Contact Center.'&lt;br />&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-1PhBHATfZswil-6VkJ2cWA" name="outline_operational_model,_8lPsmderEd-Zq9ImbgqLFQ" guid="-1PhBHATfZswil-6VkJ2cWA">
    <refinedDescription>&lt;p>&#xD;
    Develop an overview of how the software is deployed. For example, determine if the system needs to be accessed&#xD;
    remotely, or has requirements that suggest distribution across multiple nodes. Some sources of information to consider&#xD;
    are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        users (at locations), defined in user profiles and use cases&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        organization of business data&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        service level requirements&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        constraints (such as requirements to interface with legacy systems)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Provisionally assign components and data to nodes, and indicate how users access components that access data. Detailed&#xD;
    specification of nodes and connections is deferred, except where they are important for estimating or assessing&#xD;
    viability. Existing assets can be used if appropriate assets are available.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Although this is the first operational model produced in the project, and it is produced quickly and at a high level,&#xD;
    it might identify actual hardware and software products if they are known, or if it is important to make these&#xD;
    selection decisions at this time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If a non-trivial distributed system is required, then deployment units can be specified by grouping components (and&#xD;
    their different operational facets). This significantly reduces the number of things that need to be placed and the&#xD;
    level of complexity in developing the operational architecture aspect of a complex, distributed IT system.&#xD;
&lt;/p>&lt;br /></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-_QemzNns6ZbUWfLthYhoeg" name="operational_model,_8lPsmterEd-Zq9ImbgqLFQ" guid="-_QemzNns6ZbUWfLthYhoeg">
    <keyConsiderations>&lt;h5>&#xD;
    Levels of this artifact&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The artifact can be a large and complex work product.&amp;nbsp; It is therefore important to understand how it may be best&#xD;
    developed and presented, depending on the particular context.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In order to reduce the complexity of the development process, the various development techniques available take&#xD;
    advantage of a number of well-defined views and levels of completeness.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Therefore this artifact can be refined and elaborated in various ways depending on the nature of the project life cycle&#xD;
    and the development techniques used.&amp;nbsp; Useful intermediate stages of development have been defined for both the&#xD;
    &lt;strong>logical&lt;/strong> and &lt;strong>physical&lt;/strong> levels of this artifact as described within this artifact.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Degree of completeness (elaboration) and quality (refinement)&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Individual circumstances will dictate the degree of completeness (including omission) of each level of this&#xD;
    artifact.&amp;nbsp; Decisions on level of detail, focus and completeness will be based on many factors, such as&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Audience (e.g. business people, IT Architects, or Developers)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Purpose (is it to be fully specified and configured or a generalized reference pattern?)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Completeness (is it early in a project's life, or a finished artifact?)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The degree of completeness reached (or required) will also be dependent on the development process (e.g. waterfall,&#xD;
    iterative, etc.).&amp;nbsp; The levels of this artifact elaborate through degrees of completeness towards their completed&#xD;
    states while remaining synchronized and consistent with one another at each major project &quot;milestone&quot;.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Varying depth of detail&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    As well describing the operational aspect of a complete IT system, it is often helpful to develop this artifact showing&#xD;
    greater detail for particular parts of the system.&amp;nbsp; For example:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        This artifact may model a whole IT system as one or two nodes on the overall model, but a further more detailed&#xD;
        representation of parts of the IT system in a particular location may also be constructed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        This artifact may model a single part of an IT system in detail without modeling the whole IT system.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        This artifact may include the same &quot;recurring pattern&quot; of nodes and/or connections, and, in this case, a separate&#xD;
        artifact may detail the recurring pattern and be referenced by the main artifact.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h5>&#xD;
    Cross-cutting viewpoints&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    This artifact and the logical and physical levels of this artifact may be the focus of a particular viewpoint, at any&#xD;
    degree of elaboration and refinement, to address the concerns of a particular stakeholder. These cross-cutting&#xD;
    viewpoints overlap with one another.&amp;nbsp; For example, views may be constructed on this artifact for the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Application&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Technical&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Performance&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Capacity&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Availability and Recovery&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Security and Privacy Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Operability and Operations Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Systems Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Software Distribution and Installation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Distributed Data Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Problem Identification and Management&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        End User Support/Helpdesk&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Networking&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Accessibility&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        National Language Support&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Financial proprietary&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Archiving&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Such filtering does not generally change the elements in the artifact rather it simply enables a clearer focus on some&#xD;
    particular part of it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Please refer to &quot;An Introduction to the IBM Views and Viewpoints Framework for IT Systems&quot; Whitepaper for further&#xD;
    details on the views and viewpoints framework including the relationship between base and cross-cutting views.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Linkages to other work products&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    As well as a linkage via Deployment Units with the functional aspect of architecture as embodied in the Component&#xD;
    Model, this artifact has influences and/or is strongly interdependent on other areas that cover the design of the&#xD;
    infrastructure that will implement the operational aspect of architecture. For example:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Network Design: affects the application design, middleware selection, component placement, security and privacy,&#xD;
        systems management and overall operational system control.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Platform Design; the detailed design and configuration of the platforms that will implement the nodes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Storage Design; the detailed design and configuration of storage which may be shared across multiple platforms.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Site &amp;amp; Facilities Design; the detailed design and configuration of the site and facilities in the locations in&#xD;
        which nodes (implemented by platforms) are placed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Systems Management design; through its definition of how the IT system is spread out over locations and what&#xD;
        systems management components and nodes are needed at each location.&amp;nbsp; Selection of a systems management style&#xD;
        is an important decision, which determines: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                The cost of operations management&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                The cost of software distribution&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                The complexity of system management tooling&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Potential security and performance of the IT system (ability to satisfy the service level requirements)&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Existing or planned enterprise-wide IT infrastructure initiatives on which the target system will be&#xD;
        implemented.&amp;nbsp; For example, enterprise wide middleware decisions may well move function, which would otherwise&#xD;
        be duplicated across multiple applications, into a set of shared services, which are usually purchased or part of&#xD;
        an enterprise wide development effort.&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact describes the operational distribution of a system's components (which may be grouped into deployment&#xD;
    units) onto nodes, the placement of nodes and users across locations, the connections between nodes necessary to&#xD;
    support the required interactions between components, in order to achieve the system's functional and non-functional&#xD;
    requirements within the constraints of technology, skills and budget.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Operational Modeling Terminology&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    This artifact's (and that of its contained artifacts) terminology is defined within the System Description Standard R3&#xD;
    Semantic Specification (see Guidance for link) which includes definitions for the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Actors (and workers) - the roles a user or an external system play with respect to the target system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Locations - a geographical area or position.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Borders - representing the existing connection between two locations&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Components - modular units of functionality, which make this functionality available through an interface.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Deployment Units - a grouping of facets of a component that have similar characteristics.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Connectors - enable the exchange of messages (interactions) between resource containers.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Interactions - identify the messages exchanged between one or two resource containers in the context of a&#xD;
        collaboration, and the sequencing of these messages via their associated send/receive events.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Nodes - a collection of components fulfilling a specific responsibility with a certain quality of service within&#xD;
        the target system.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Connections - supports the required connectivity between connectable model elements.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Zones - an aggregation of a number of model elements with a common (sub-) set of values for a particular&#xD;
        non-functional requirement and/or non-functional characteristic.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Boundaries - associated with a change in value for a particular non-functional requirement and/or characteristic&#xD;
        between two model elements.&amp;nbsp;&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Depending on the development approach adopted and/or the context, it can be very helpful to create levels of this&#xD;
    artifact.&amp;nbsp; The two basic levels of this artifact are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Logical&lt;/strong>:&amp;nbsp; This level describes the characteristics and capabilities of the operational aspect&#xD;
        of the system architecture in a &lt;strong>technology independent and product neutral&lt;/strong> manner.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Physical&lt;/strong>:&amp;nbsp; This level describes characteristics and capabilities of the operational aspect of&#xD;
        the system architecture in a &lt;strong>technology and product dependent&lt;/strong> manner.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Both levels of this artifact may be further described at three different sub-levels relating to the degree to which the&#xD;
    level has been sized:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Unsized&lt;/strong> (or unranged) - the technology and products are specified to support the components&#xD;
        deployed but not sized and without detailing how the system will achieve the service level characteristics.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Ranged&lt;/strong> - the technology and products are specified to support a bounded range of requirements for&#xD;
        a defined range of circumstances.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Sized&lt;/strong> - the technology and products are specified and sized to support the components deployed and&#xD;
        details how the system will achieve the service level characteristics.&#xD;
    &lt;/li>&#xD;
&lt;/ul></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-4TjGaH03WjFSn4odVmXdFA" name="component_specification,_MRmJgOcsEeG55KAi5K_cIQ" guid="-4TjGaH03WjFSn4odVmXdFA">
    <keyConsiderations>&lt;p>&#xD;
    Points to consider when deciding whether to use a Component Specification:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The Component Specification provides value when the architecture is complex, such that new team members need a&#xD;
        simplified, abstracted model to understand it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The extra work required to ensure that the Component Specification and Executable Architecture remain consistent&#xD;
        must be balanced against the benefit of having a view of the system that represents only the most important details&#xD;
        of how the system works. It can be very costly to maintain a high degree of fidelity between the Component&#xD;
        Specification and Executable Architecture. As the complexity of the Component Specification increases, so does the&#xD;
        cost to maintain it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you no longer maintain the Component Specification, its value decays rapidly. At some point, it will no longer&#xD;
        accurately reflect the Executable Architecture. Deciding to no longer maintain the Component Specification may be&#xD;
        appropriate (it may have served its purpose), but the decision should be a conscious one.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component Specifications tend to be useful in companies where systems live for decades, or where there are many&#xD;
    variants of the system.&lt;br />&#xD;
&lt;/p></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact specifies the details of a component identified in the Component Model. The specification shows the&#xD;
    interfaces offered and used by the component, identifies where business rules are placed, and details the operations&#xD;
    and their signatures for each interface.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Component Interfaces&lt;/strong> - An interface specifies one or more operation signatures and is both offered and&#xD;
    used by a component. Offering an interface means the component makes the interface available for other components to&#xD;
    use.&amp;nbsp;&amp;nbsp;Each interface provides a unique and well-defined set of operations. Hiding the structure of a&#xD;
    component and its data behind an interface allows that data to be changed without affecting how the interface is&#xD;
    used.&amp;nbsp; The actual composition of that data may change, but the interface that provides access to that data is&#xD;
    fixed. Interfaces also describe the state of a component.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Business Rules&lt;/strong> - Business Rules dictate the behavior of a system, and the component specification&#xD;
    defines how the system implements the business rules.&amp;nbsp; For example, a business rule may state that Internet&#xD;
    transactions for an on-line order can not exceed $1000 for a given account. A component that manages account&#xD;
    transactions may define an on-line transactions interface that implements this business rule.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Operations&lt;/strong> - Fully specified Component Specifications assign operations and operation signatures to&#xD;
    the interfaces and may define pre- and post-conditions on the operations.&amp;nbsp; Pre- and post-conditions specify the&#xD;
    effect of an operation without prescribing an algorithm or implementation.&amp;nbsp;A post-condition specifies the effect&#xD;
    of the operation on the components data or state.&amp;nbsp;A pre-condition is the condition under which the operation&#xD;
    guarantees that the post-condition is true.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-J4iJkUgePfA-W65qc95Jcw" name="code_analysis_guidelines,_cUuWFtesEd-Zq9ImbgqLFQ" guid="-J4iJkUgePfA-W65qc95Jcw">
    <keyConsiderations>The most important thing about coding guidelines is to have them. Everyone has their stylistic preferences, but a enforcing&#xD;
a single style greatly improves readability and maintainability. Avoid ignoring coding guidelines just because it's&#xD;
difficult to come to agreement. Choose a set of guidelines get coding.</keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    Code analysis guidelines includes information for the static and runtime evaluation of the implementation (code).&#xD;
    Static guidelines focus on code that is not currently running. Dynamic guidelines focus on evaluating the behavior of&#xD;
    the software as the code is executing.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Static analysis includes:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Coding guidelines that give the implementation a familiar look and feel to everyone on the team, and make it easier&#xD;
        to find code blocks and commonly used areas of code (methods, case statements, etc). These guidelines makes the&#xD;
        code more maintainable and more efficient to produce.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Code dependency that evaluates how different implementation modules depend upon each other. This can improve&#xD;
        coupling and cohesion at the implementation level, for example.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Code complexity that helps developers judge if the code has become too complex to be maintained efficiently.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    See the definition of &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../practice.tech.design_driven_implementation.base-ibm/guidances/termdefinitions/runtime_analysis_E9330E42.html&quot;&#xD;
     guid=&quot;_iWLT0H9mEd2zS8U3DVRSmQ&quot;>runtime analysis&lt;/a>&amp;nbsp;for more information.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Automated tools and techniques can cover more areas of static and runtime analysis. Use this work product to list all&#xD;
    the areas that need to be examined in the implementation and the tools used to examine the implementation.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-buEmZVIsTb9N13i-w24-0Q" name="implementation,_cUuWF9esEd-Zq9ImbgqLFQ" guid="-buEmZVIsTb9N13i-w24-0Q">
    <refinedDescription>&lt;p>&#xD;
    This artifact is the collection of one or more of these elements:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Source code files&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Data files&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Build scripts&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Other files that are transformed into the executable system&#xD;
    &lt;/li>&#xD;
&lt;/ul></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-FCnQtf95BpcnsnLeyCTN1A" name="envision_the_architecture,_1Il4UtesEd-Zq9ImbgqLFQ" guid="-FCnQtf95BpcnsnLeyCTN1A">
    <refinedDescription>In this task, you define architectural goals and identify inputs to the architecture, including requirements, constraints,&#xD;
and reusable assets. You make and document key decisions about the structure of the architecture. You sketch a high level&#xD;
overview of the architecture.</refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-qjeqYIU0f1zJmpAfujTmaw" name="architectural_decisions,_1Il4VdesEd-Zq9ImbgqLFQ" guid="-qjeqYIU0f1zJmpAfujTmaw">
    <keyConsiderations>&lt;p>&#xD;
    Some important considerations for making and implementing architectural decisions:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Make sure the process for making decisions has the right level of sponsorship necessary to enforce those decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Make architecturally significant decisions early and be sure to validate high risk decisions using an executable&#xD;
        architecture&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Review and update architectural decisions as development progresses and update this artifact so it reflects any&#xD;
        changes to your decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        It is not necessary to document every minute decision you make when developing the architecture; focus on those&#xD;
        that are controversial or are based on reasoning that is not obvious&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact documents key architectural decisions and the rationale behind those decisions.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-mwyY-E3zen_cZKfdJORYzQ" name="architecture_overview,_1Il4VtesEd-Zq9ImbgqLFQ" guid="-mwyY-E3zen_cZKfdJORYzQ">
    <keyConsiderations>As communication is its main purpose, it is more important for the description of the architecture to be simple, brief,&#xD;
clear, and understandable than comprehensive or accurate in all details.</keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact provides an overview of the main conceptual elements and relationships of an architecture, which might&#xD;
    include candidate subsystems, components, nodes, connections, data stores, users and external systems. As such, it&#xD;
    represents the governing ideas and candidate building blocks of the architecture.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-AzUO_drk2ZjvTzBD3lHoPQ" name="document_architectural_decisions,_1Il4V9esEd-Zq9ImbgqLFQ" guid="-AzUO_drk2ZjvTzBD3lHoPQ">
    <refinedDescription>&lt;p>&#xD;
    In this task, you state each architectural issue or problem, consider alternatives, make and document decisions, and&#xD;
    provide rationale for each decision.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.tech.common.extend_supp-ibm/guidances/guidelines/documenting_architectural_decisions_8EF0BD39.html&quot;&#xD;
    guid=&quot;_RtLzgIByEd2z9IawWqZSFw&quot;>Guideline: Documenting Architectural Decisions&lt;/a>&amp;nbsp;for more information.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
</xmi:XMI>
