<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-P6hRqSyLCfOTMBMt74oaJA" name="new_guideline,_LeiNkMgUEd67koQUdRbVsg" guid="-P6hRqSyLCfOTMBMt74oaJA" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This guideline describes, by way of an example, how to derive statechart diagrams from a consistent set of activity and&#xD;
    sequence diagrams.&amp;nbsp; The example is a security system used to grant&amp;nbsp;exit&amp;nbsp;from a facility to authorized&#xD;
    users that swipe a valid security card.&amp;nbsp; The users get three attempts at swiping the card and if the card is not&#xD;
    validated by the third attempt&amp;nbsp;exit is denied.&amp;nbsp; The following input information is available:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        An activity diagram specifying the functional flow for the &lt;em>ConrolExit&lt;/em> use case(see Figure 1);&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A&amp;nbsp;sequence diagram illustrating&amp;nbsp;the nominal scenario of the &lt;em>ControlExit&lt;/em> use case, in which the&#xD;
        user is granted&amp;nbsp;exit (see Figure 2a); and&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A&amp;nbsp;sequence diagram illustrating an exception scenario of the &lt;em>ControlExit&lt;/em> use case, in which the user&#xD;
        is denied access (see Figure 2b).&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Each of these diagrams also have associated pre- and post-conditions.&#xD;
&lt;/p>&#xD;
&lt;center>&#xD;
    &lt;img alt=&quot;UC BB Activity Diagram Uc2 ControlExit&quot; src=&quot;resources/uc_bb_activity_diagram_uc2_controlexit.jpg&quot;     width=&quot;406&quot; height=&quot;416&quot; />&lt;br />&#xD;
    &lt;strong>Figure 1: Use-Case Black-Box Activity Diagram for Uc2 &lt;em>ControlExit&lt;/em>&lt;/strong>&#xD;
&lt;/center>&#xD;
&lt;center>&#xD;
    Pre-Condition: the security system (SecSys) is configured and activated&lt;br />&#xD;
    Note: Actions stereotyped &amp;lt;&amp;lt;MessageAction&amp;gt;&amp;gt; contain only message(s) to and/or from actors.&lt;br />&#xD;
&lt;/center>&lt;br />&#xD;
&lt;br />&#xD;
&lt;center>&#xD;
    &lt;img alt=&quot;Uc2 Nominal Flow&quot; src=&quot;resources/uc2_nominal_flow.jpg&quot; width=&quot;473&quot; height=&quot;481&quot; />&lt;br />&#xD;
    &lt;strong>Figure 2a: Nominal Flow of Uc2_Sc1&lt;/strong> &lt;em>&lt;strong>ControlExit&lt;/strong>&amp;nbsp;&lt;/em>&#xD;
&lt;/center>&#xD;
&lt;center>&#xD;
    &amp;nbsp;Pre-Condition: SecSys configured and activated&#xD;
&lt;/center>&#xD;
&lt;center>&#xD;
    Post-Condition: Access Point locked&#xD;
&lt;/center>&lt;br />&#xD;
&lt;center>&#xD;
    &amp;nbsp;&lt;img alt=&quot;Uc2 Exception Flow&quot; src=&quot;resources/uc2_exception_flow.jpg&quot; width=&quot;469&quot; height=&quot;502&quot; />&lt;br />&#xD;
    &lt;strong>Figure 2b: Exception Flow of Uc2_Sc2 &lt;em>ControlExit&lt;/em>&lt;/strong>&amp;nbsp;&#xD;
&lt;/center>&#xD;
&lt;center>&#xD;
    Pre-Condition: SecSys configured and activated, Card validation failed two times&#xD;
&lt;/center>&#xD;
&lt;center>&#xD;
    Post-Condition: Alarm reset&#xD;
&lt;/center>&lt;br />&#xD;
&lt;br />&#xD;
&lt;h3>&#xD;
    To derive a statechart diagram:&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    Step 1: Identify wait states and action states&#xD;
&lt;/h4>&#xD;
&lt;h5>&#xD;
    1.1 Identify &lt;em>Wait States&lt;/em>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    In a wait state an object waits for an event to happen i.e. it&amp;nbsp;just consumes time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    From the use-case black-box activity diagram (Figure 1), identify actions with IN actor pins.&amp;nbsp; From the use-case&#xD;
    black-box sequence diagrams (Figure 2a and Figure 2b), identify the messages (&lt;em>receptions&lt;/em>) that trigger the&#xD;
    selected actions. For each of the identified actions, create a wait state in the statechart diagram named&#xD;
    &lt;strong>WaitFor&lt;/strong>&amp;lt;&lt;em>ReceptionName&lt;/em>&amp;gt;.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In cases where the use-case black-box sequence diagram shows a timeout event (t_Unlocked in Figure 2a), create&amp;nbsp;a&#xD;
    wait state in the statechart diagram with a name that describes the actual system status. The results are shown in&#xD;
    Figure 3a, below.&#xD;
&lt;/p>&#xD;
&lt;center>&#xD;
    &lt;img alt=&quot;Wait States of Uc2&quot; src=&quot;resources/uc2_wait_states.jpg&quot; width=&quot;337&quot; height=&quot;331&quot; />&lt;br />&#xD;
    &lt;strong>Figure 3a: Wait States of Uc2 &lt;em>ControlExit&lt;/em>&lt;/strong>&#xD;
&lt;/center>&#xD;
&lt;h5>&#xD;
    &lt;br />&#xD;
    1.2 Identify &lt;em>Action States&lt;/em>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    An action state is a state whose purpose is to execute an entry action, after which it takes a completion transition to&#xD;
    another state. It is a kind of dummy state that is useful for organizing state machines into logical structures.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    From the use-case black-box activity diagram (Figure 1), identify actions that are followed by a decision node. For&#xD;
    each of these actions create&amp;nbsp;an action state in the statechart diagram with the name of the action (naming&#xD;
    convention: &amp;lt;&lt;em>ActionName&lt;/em>&amp;gt;&lt;strong>ing&lt;/strong>) and allocate the relevant action to it using MOORE syntax.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note: Besides the output-relevant action, an action-state may also have additional context-related actions allocated to&#xD;
    it. The results are shown in Figure 3b, below.&#xD;
&lt;/p>&#xD;
&lt;center>&#xD;
    &lt;img alt=&quot;Action States of Uc2&quot; src=&quot;resources/uc2_action_states.jpg&quot; width=&quot;494&quot; height=&quot;275&quot; />&lt;br />&#xD;
    &lt;strong>Figure 3b: Action States of Uc2 &lt;em>ControlExit&lt;/em>&lt;/strong>&#xD;
&lt;/center>&#xD;
&lt;h4>&#xD;
    &lt;br />&#xD;
    Step 2: Create a flat statechart&#xD;
&lt;/h4>&#xD;
&lt;h5>&#xD;
    2.1 Identify the Initial State&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Identify the initial state&amp;nbsp;by drawing an&amp;nbsp;initial pseudo-state node. If attributes need to be initialized add&#xD;
    respective actions to the initial transition. See&amp;nbsp; &lt;em>/ScFailCount=0;&lt;/em> in Figure 4, for example.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    2.2 Identify Transitions, Triggering Events, and Associated Actions&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The transitions between the states and associated triggering events – including guarded condition(s) - are identified&#xD;
    through analysis of the sequence diagrams (Figure 2a and Figure 2b). With regard to the description in the statechart&#xD;
    it is recommended to follow MEALY syntax.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Select a use-case scenario. Replicate the scenario in the statechart diagram as follows:&#xD;
&lt;/p>&#xD;
&lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
    &lt;p>&#xD;
        Start from the initial state.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        In the sequence diagram identify the event (message) and – if needed – guarded condition(s) that trigger a&#xD;
        transition and the associated sequence of actions.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        In the statechart diagram identify the target state.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Connect the two states with a transition line.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Label the transition following the statechart notation for labeling transitions: &lt;strong>Event [Condition] /&#xD;
        Action&lt;/strong>.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        If the target state is an action state, add to the transition label only those actions that are not already&#xD;
        allocated to the state.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Proceed in the sequence diagram and repeat the previous steps.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Repeat the replication of scenarios in the statechart for all captured use case scenarios.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Figure 4, below,&amp;nbsp;shows the resulting statechart capturing both scenarios in the example.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    2.3 Execute the Statechart&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Verify the correctness of the captured state-based behavior through model execution using the input use case scenarios&#xD;
    (Figure 2a and Figure 2b) as the basis for respective stimuli.&#xD;
&lt;/p>&#xD;
&lt;center>&#xD;
    &lt;img alt=&quot;Flat statechart of Uc2&quot; src=&quot;resources/uc2_flat_statechart.jpg&quot; width=&quot;579&quot; height=&quot;497&quot; />&lt;br />&#xD;
    &lt;strong>Figure 4: Flat Statechart of Uc2 &lt;em>ControlExit&lt;/em>&lt;/strong>&#xD;
&lt;/center>&#xD;
&lt;h4>&#xD;
    &lt;br />&#xD;
    Step 3: Re-factor the Statechart with regard to hierarchy&#xD;
&lt;/h4>&#xD;
&lt;table title=&quot;&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;95%&quot; align=&quot;center&quot;>&#xD;
    &lt;tbody>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;h5>&#xD;
                    3.1 Identify State Hierarchies&#xD;
                &lt;/h5>&#xD;
                &lt;p>&#xD;
                    Once the flat statechart is verified, look for ways to simplify it by structuring it hierarchically.&#xD;
                    Identify states that can be aggregated. Grouping criteria could be the following:&#xD;
                &lt;/p>&#xD;
                &lt;ul>&#xD;
                    &lt;li>&#xD;
                        System modes.&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        System phases.&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        Reuse of state patterns.&#xD;
                    &lt;/li>&#xD;
                &lt;/ul>&#xD;
                &lt;p>&#xD;
                    Also look for situations where the aggregation of state transitions simplifies the statechart.&#xD;
                &lt;/p>&#xD;
                &lt;p>&#xD;
                    Inspection of the flat statechart in Figure 4 reveals that the following 3 states can be considered&#xD;
                    sub-states of a composite state called &lt;em>ProcessingSecurityCard&lt;/em>:&#xD;
                &lt;/p>&#xD;
                &lt;ul>&#xD;
                    &lt;li>&#xD;
                        &lt;em>ValidatingSecurityCard.&lt;/em>&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        &lt;em>FlagingSecurityCardFailure.&lt;/em>&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        &lt;em>WaitFor_req_ReadSecurityCard&lt;/em> in the case of a card failure.&#xD;
                    &lt;/li>&#xD;
                &lt;/ul>&#xD;
                &lt;p>&#xD;
                    This is depicted in Figure 5b.&#xD;
                &lt;/p>&#xD;
                &lt;p>&#xD;
                    As &lt;em>ScFailCount&lt;/em> is a local attribute, the initialization is added to the default entry of the&#xD;
                    composite state.&#xD;
                &lt;/p>&#xD;
                &lt;p>&#xD;
                    Furthermore, the sub-states &lt;em>FlagingSecurityCardFailure&lt;/em> and&#xD;
                    &lt;em>WaitFor_req_ReadSecurityCard&lt;/em> can be aggregated in the composite state &lt;em>ValidationFail&lt;/em>,&#xD;
                    thus denoting the fail mode within the &lt;em>ProcessingSecurityCard&lt;/em> state.&#xD;
                &lt;/p>&#xD;
                &lt;p>&#xD;
                    Note the different descriptions of the transitions out of the composite state. In the case of&#xD;
                    &lt;em>CardStatus==&quot;Pass&quot;&lt;/em> the triggering condition and associated action is captured in the top-level&#xD;
                    statechart (Figure 5a) as a high-level interrupt. In the case of a third-time failure the respective&#xD;
                    triggering condition and associated action&amp;nbsp;are captured within the &lt;em>ProcessingSecurityCard&lt;/em>&#xD;
                    state and linked to the top-level statechart via an Exit Point (&lt;em>Fail3Times&lt;/em>).&lt;br />&#xD;
                    &lt;br />&#xD;
                    States on the flat statechart in Figure 4 that relate to the access point control can be aggregated&#xD;
                    into a composite state &lt;em>UnlockingAndLockkingAccessPoint&lt;/em>, as shown in Figure 5c. This state&#xD;
                    includes the messages sent to the access point. Furthermore, the wait states&#xD;
                    &lt;em>WaitFor_evAccessPointUnlocked&lt;/em> and &lt;em>WaitFor_evAccessPointLocked&lt;/em> are merged to one wait&#xD;
                    state called &lt;em>WaitForAccessPointFeedback&lt;/em>.&amp;nbsp; The exit out of the composite state is captured&#xD;
                    in the top-level statechart.&#xD;
                &lt;/p>&#xD;
                &lt;p>&#xD;
                    Figure 5a shows the final hierarchical statechart of the use case Uc2 &lt;em>ControlExit&lt;/em>.&#xD;
                &lt;/p>&#xD;
                &lt;h5>&#xD;
                    3.2 Execute the Statechart&#xD;
                &lt;/h5>&#xD;
                &lt;p>&#xD;
                    Verify the correctness of the captured state-based behavior through model execution using the black-box&#xD;
                    use case scenarios as the basis for respective stimuli.&#xD;
                &lt;/p>&#xD;
                &lt;p>&#xD;
                    &lt;br />&#xD;
                    &amp;nbsp;&#xD;
                &lt;/p>&lt;br />&#xD;
                &lt;br />&#xD;
                &lt;p>&#xD;
                    &lt;br />&#xD;
                    &lt;br />&#xD;
                    &lt;br />&#xD;
                    &lt;br />&#xD;
                    &lt;br />&#xD;
                    &amp;nbsp;&#xD;
                &lt;/p>&lt;br />&#xD;
                &lt;br />&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                &lt;center>&#xD;
                    &lt;img alt=&quot;Hierarchical Statechart of Uc2&quot; src=&quot;resources/uc2_hierachical_statechart.jpg&quot; width=&quot;409&quot;                     height=&quot;387&quot; />&lt;br />&#xD;
                    &lt;strong>Figure 5a: Hierarchical Statechart of Uc2 &lt;em>ControlExit&lt;/em>&lt;/strong>&#xD;
                &lt;/center>&#xD;
                &lt;center>&#xD;
                    &lt;br />&#xD;
                    &lt;img alt=&quot;Composite ProcessingCardData&quot; src=&quot;resources/composite_processingcarddata.jpg&quot; width=&quot;466&quot;                     height=&quot;328&quot; />&lt;br />&#xD;
                    &lt;strong>Figure 5b: Composite &lt;em>ProcessingCardData&lt;/em>&lt;/strong>&#xD;
                &lt;/center>&#xD;
                &lt;center>&#xD;
                    &lt;br />&#xD;
                    &lt;img alt=&quot;Composite State UnlockingAndLockingAccessPoint&quot;                     src=&quot;resources/cmpst_state_unlock_lock_accesspoint.jpg&quot; width=&quot;432&quot; height=&quot;278&quot; />&lt;br />&#xD;
                    &lt;strong>Figure 5c: Composite State &lt;em>UnlockingAndLockingAccessPoint&lt;/em>&lt;/strong>&#xD;
                &lt;/center>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/tbody>&#xD;
&lt;/table></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
