<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-rgdtC49I3Bgp5yFmQsbNtA" name="new_guideline,_Yg1bYITBEd2AfZddKTmDRA" guid="-rgdtC49I3Bgp5yFmQsbNtA" authors="Kathryn Fryer" changeDate="2010-10-20T07:37:14.909-0700" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    Purpose&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Defect Density&amp;nbsp;indicates the code quality attained in the deliverable, based on the number of defects found,&#xD;
    fixed, and remaining (not yet fixed). When comparing data over multiple releases, you should be able to draw&#xD;
    conclusions about how well you have managed to identify defects.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    While this Defect Density description focuses on pre-release analysis, Defect Density can be monitored post-release to&#xD;
    track how many defects are found by customers (not identified during development).&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Definition&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Defect Density = Number of total defects found, closed (fixed), and remaining per some unit (typically SLOC). It can be&#xD;
    useful to view defects grouped by:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Component&lt;/b>, to determine whether any particular component has quality issues (this can be called &lt;i>defect&#xD;
        density by component&lt;/i> or &lt;i>defect distribution by component&lt;/i>)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Requirement&lt;/b>, to determine whether any particular requirement has quality issues (this can be called&#xD;
        &lt;i>defect density by requirement&lt;/i> or &lt;i>defect distribution by requirement&lt;/i>)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Average Defect Density = Number of total defects found, closed (fixed), and remaining / unit&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In this measurement method, &lt;code>unit&lt;/code> can be source line of code or SLOC (&lt;code>total&lt;/code>, and &lt;code>new or&#xD;
    changed &lt;font face=&quot;Arial&quot;>SLOCs&lt;/font>&lt;/code>), FunctionPoint, use case, or whatever else you measure. It can also be&#xD;
    useful to group by component or requirement, and use in conjunction with defect density (mentioned previously).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Count&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Total defects found, closed, and remaining&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Unit: SLOC, FunctionPoint, use case, or whatever else you measure.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    Analysis&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    You can use a bar, stacked bar, or grouped (stacked) bar chart to show the number of defects in each category,&#xD;
    depending on whether you are viewing by component or requirement, by severity, or simply totals. To show trends over&#xD;
    time, you can use a series of bars, or a line chart.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    During development, expect to see the total defect count increase in relation to your testing activities. While you&#xD;
    want to see the number of closed defects increasing as well, there may still be a large number of defects remaining (a&#xD;
    defect is not closed until the fix has been verified).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As you&amp;nbsp;prepare the deliverable for shipment, you typically want to see a low number of remaining defects, and few&#xD;
    or no remaining high-severity defects. Set targets for an acceptable level of remaining defects (usually a percentage&#xD;
    of the total, with perhaps zero outstanding high-severity defects).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A high number of total defects is not necessarily bad, as long as your total fixed defects is acceptable. You can set&#xD;
    targets for these numbers based on historical data. For example, this could be your historical defect rate per SLOC (or&#xD;
    function point, or whatever you are measuring) on previous similar projects, or within the organization.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Defect density should decline over time: 4-6% annually over the long term. Defect density and trending should be used&#xD;
    to estimate maintenance effort on a project. As new code is implemented, the defect density should track the existing&#xD;
    trends. Once the SLOCs are known, you can estimate the number of defects and multiply by the average repair time to&#xD;
    estimate the effort required to implement the maintenance operations. Typical defect densities at customer ship are 0.8&#xD;
    to 1.0 defects for new code, and decline rapidly in the first year to 0.08 to 0.1 defects per 1,000 SLOC for existing&#xD;
    code. This decline is also an indication of the usage of the product.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Use this measure in conjunction with the &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.tech.common.extend_supp_metrics-ibm/guidances/supportingmaterials/defect_trends_2E2A9ABF.html&quot; guid=&quot;_AIQmoITEEd2AfZddKTmDRA&quot;>Defect Trends&lt;/a>&amp;nbsp;metric.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The following figure is an example of a defect density report.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;defect density&quot; src=&quot;./resources/defect_density.gif&quot; />&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Collection and reporting tools&#xD;
&lt;/h3>IBM&amp;reg; Rational&amp;reg; Quality Manager&amp;reg; collects defect density data. IBM&amp;reg; Rational&amp;reg; Insight&amp;reg; reports on this metric. &lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
