<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1">
  <org.eclipse.epf.uma:ProcessDescription xmi:id="-QTRlRlCyIcguvlQ28qxrgw" name="service_realization_decisions,_6GUkga38Ed6VrvYQQTveHA" guid="-QTRlRlCyIcguvlQ28qxrgw" version="7.5.0"/>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-Y2sHg4QI88TT95N3cygrDw" name="detail_the_service_components_layer,_n_CZkK39Ed6VrvYQQTveHA" guid="-Y2sHg4QI88TT95N3cygrDw">
    <refinedDescription>&lt;p>&#xD;
    In this task, we leverage prior work performed during &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../practice.tech.soma.service_realization.base-ibm/tasks/document_service_realization_decisions_FBBF29EC.html&quot; guid=&quot;_3ad-MGWuEd6Zd-lbA790BQ&quot;>Task: Document Service Realization Decisions&lt;/a>&amp;nbsp;to detail the designs of the&#xD;
    Service, Technical, and Functional components that realize services.&amp;nbsp; We assume that we have the following level&#xD;
    of artifacts in hand:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A completed Service Model;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A Component Model, including (at least) external specification of Service, Functional, and Technical components,&#xD;
        their relationships,&amp;nbsp;and the behavioral flows between them;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Architectural Decisions, including realization decisions for each Service Component.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Unless this is a greenfield development, it is likely that a Component Design artifact, which documents the internal&#xD;
    details of the components,&amp;nbsp;exists with some usable content.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    We further assume that IBM's &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../core.tech.common.extend_supp_soa-ibm/guidances/concepts/soa_solution_stack_1DD21069.html&quot; guid=&quot;_PlxhEGWuEd6Zd-lbA790BQ&quot;>SOA Solution Stack&lt;/a> is being used as the SOA functional reference architecture.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The results of this task include the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Detailed designs of the Service, Functional, and Technical components, ready for implementation;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Details of how the components will be integrated at run-time; and&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Details of how the components will leverage the resources from the Operational Systems layer of the SOA Solutions&#xD;
        Stack.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The following steps are not necessarily performed in sequence.&amp;nbsp; Rather, view them as a collection of actions to be&#xD;
    performed as the service components are detailed.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-vhiJQIRsZTFmoohNWfTrRg" name="architectural_decisions,_n_CZkq39Ed6VrvYQQTveHA" guid="-vhiJQIRsZTFmoohNWfTrRg">
    <keyConsiderations>&lt;p>&#xD;
    Some important considerations for making and implementing architectural decisions:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Make sure the process for making decisions has the right level of sponsorship necessary to enforce those decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Make architecturally significant decisions early and be sure to validate high risk decisions using an executable&#xD;
        architecture&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Review and update architectural decisions as development progresses and update this artifact so it reflects any&#xD;
        changes to your decisions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        It is not necessary to document every minute decision you make when developing the architecture; focus on those&#xD;
        that are controversial or are based on reasoning that is not obvious&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact documents key architectural decisions and the rationale behind those decisions.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-B6g6I-y0h_hT9jtLUyTAsA" name="component_model,_n_CZlK39Ed6VrvYQQTveHA" guid="-B6g6I-y0h_hT9jtLUyTAsA">
    <keyConsiderations>&lt;p>&#xD;
    Points to consider when deciding whether to use a Component Model:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A Component Model is useful when you must design the system for multiple target environments, with separate design&#xD;
        architectures. The Component Model is an abstraction, or a generalization, of the system design. It omits most of&#xD;
        the details of the design in order to provide an overview of the system's functionality.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Component Model provides value when the design is complex, such that new team members need a simplified,&#xD;
        abstracted model to understand it. A well-defined architecture can serve the same purpose.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Balance the extra work required to ensure that the component and design models remain consistent against the&#xD;
        benefit of having a view of the system that represents only the most important details of how the system works. It&#xD;
        can be very costly to maintain a high degree of fidelity between the Component Model and the system design. A less&#xD;
        ambitious approach might be to maintain the Component Model with only the most important components and the key&#xD;
        abstractions in the design. As the complexity of the Component Model increases, so does the cost to maintain it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you no longer maintain the Component Model, its value decays rapidly. At some point, it no longer accurately&#xD;
        reflects the current functional design of the system. Deciding to no longer maintain the Component Model may be&#xD;
        appropriate, as it may have served its purpose, but the decision should be a conscious one.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models tend to be useful in companies where systems live for decades, or where there are many variants of the&#xD;
    system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To ensure the successful development of a component model on a project, your team should:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Create a stable and coherent structure&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Focus on the right levels of abstraction&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Develop relationship and interaction diagrams in parallel&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Select architecturally significant requirements as inputs to the Component Model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Plan how your team will leverage the Component Model throughout the project lifecycle&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    The component model describes the structure of a system in terms of its software components with their&#xD;
    responsibilities, interfaces, relationships, and the way they collaborate to deliver the required functionality. The&#xD;
    component model is the main artifact documenting the functional view of the architecture and serves as an abstraction&#xD;
    of the design. Components identified may be decomposed into further component models before they complete the&#xD;
    specification required for detailed design.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Component models help define and document:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The structure of the system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The recurring interactions and dependencies between sets of components&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The components present within an enterprise, each of which may be made up of smaller components.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models are documented at 2 levels:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The logical level - focuses on specifying the components' responsibilities and characteristics required to deliver&#xD;
        the requirements. These specifications are technology and product neutral.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The physical level -focuses on how to implement the components to meet the previously established specifications.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You may transform logical components into physical components via custom development, the purchase of products, or the&#xD;
    reuse of assets.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It may be important to maintain a separation between logical and physical components on larger projects. However,&#xD;
    smaller or less complex projects may evolve a single logical component model into a physical model, and end up with&#xD;
    only a physical model.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Examples of components at the logical level are a 'Message Bus' or a 'Customer Relationship Manager' component.&#xD;
    Components at the physical level that implement these logical components might be 'IBM WebSphere Message Broker' or&#xD;
    'Siebel Contact Center.'&lt;br />&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-cA1Eg9_TV5HwIOnZHVOBKA" name="component_design,_n_CZla39Ed6VrvYQQTveHA" guid="-cA1Eg9_TV5HwIOnZHVOBKA">
    <keyConsiderations>&lt;p>&#xD;
    In circumstances where the design of a component involves applying well understood, existing strategies, it is possible&#xD;
    that you will not need a &lt;em>new&lt;/em> design. In those cases, you can simply refer to some existing design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Decide on the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Properties to include&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Whether or not any extensions to the Unified Modeling Language (UML) are needed; for example, your project may&#xD;
        require additional stereotypes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The level of formality applied to the model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If the model is mapped to other models, such as an architectural models and how&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Whether a single model or multiple models will be used&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        How the model is mapped to an implementation model (this is very much affected by the decision to use&#xD;
        reverse-engineering, code generation, or round-trip engineering); see Concept: Mapping from Code to Design&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact is a specification of the internal structure and behavior of one or more major structural elements&#xD;
    (components) of a system.&amp;nbsp; Each component realization describes the internal behaviors of a component that realize&#xD;
    its interfaces.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
  <org.eclipse.epf.uma:DescriptorDescription xmi:id="-RMsNWCv5cib4aK5NASvzpQ" name="component_specification,_9-t-4azsEeCJ-7p1IAy8Iw" guid="-RMsNWCv5cib4aK5NASvzpQ">
    <keyConsiderations>&lt;p>&#xD;
    Points to consider when deciding whether to use a Component Specification:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The Component Specification provides value when the architecture is complex, such that new team members need a&#xD;
        simplified, abstracted model to understand it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The extra work required to ensure that the Component Specification and Executable Architecture remain consistent&#xD;
        must be balanced against the benefit of having a view of the system that represents only the most important details&#xD;
        of how the system works. It can be very costly to maintain a high degree of fidelity between the Component&#xD;
        Specification and Executable Architecture. As the complexity of the Component Specification increases, so does the&#xD;
        cost to maintain it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you no longer maintain the Component Specification, its value decays rapidly. At some point, it will no longer&#xD;
        accurately reflect the Executable Architecture. Deciding to no longer maintain the Component Specification may be&#xD;
        appropriate (it may have served its purpose), but the decision should be a conscious one.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component Specifications tend to be useful in companies where systems live for decades, or where there are many&#xD;
    variants of the system.&lt;br />&#xD;
&lt;/p></keyConsiderations>
    <refinedDescription>&lt;p>&#xD;
    This artifact specifies the details of a component identified in the Component Model. The specification shows the&#xD;
    interfaces offered and used by the component, identifies where business rules are placed, and details the operations&#xD;
    and their signatures for each interface.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Component Interfaces&lt;/strong> - An interface specifies one or more operation signatures and is both offered and&#xD;
    used by a component. Offering an interface means the component makes the interface available for other components to&#xD;
    use.&amp;nbsp;&amp;nbsp;Each interface provides a unique and well-defined set of operations. Hiding the structure of a&#xD;
    component and its data behind an interface allows that data to be changed without affecting how the interface is&#xD;
    used.&amp;nbsp; The actual composition of that data may change, but the interface that provides access to that data is&#xD;
    fixed. Interfaces also describe the state of a component.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Business Rules&lt;/strong> - Business Rules dictate the behavior of a system, and the component specification&#xD;
    defines how the system implements the business rules.&amp;nbsp; For example, a business rule may state that Internet&#xD;
    transactions for an on-line order can not exceed $1000 for a given account. A component that manages account&#xD;
    transactions may define an on-line transactions interface that implements this business rule.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Operations&lt;/strong> - Fully specified Component Specifications assign operations and operation signatures to&#xD;
    the interfaces and may define pre- and post-conditions on the operations.&amp;nbsp; Pre- and post-conditions specify the&#xD;
    effect of an operation without prescribing an algorithm or implementation.&amp;nbsp;A post-condition specifies the effect&#xD;
    of the operation on the components data or state.&amp;nbsp;A pre-condition is the condition under which the operation&#xD;
    guarantees that the post-condition is true.&#xD;
&lt;/p></refinedDescription>
  </org.eclipse.epf.uma:DescriptorDescription>
</xmi:XMI>
