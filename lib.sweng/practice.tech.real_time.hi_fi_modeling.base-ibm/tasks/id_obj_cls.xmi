<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:TaskDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-HzmYYE7aKJCllflfR5AY-A" name="id_obj_cls,_dHexsLeMEd-05egMquN4Dg" guid="-HzmYYE7aKJCllflfR5AY-A" version="7.5.0">
  <mainDescription>There are many different ways to identify objects and classes, their features, relations, and behaviors. These are known as&#xD;
object identification strategies. These strategies are neither completely overlapping nor completely orthogonal. It is&#xD;
usually enough to apply 2-4 of these strategies to find all the objects in the analysis collaboration.</mainDescription>
  <sections xmi:id="_matvgOB8Ed-aE9U0mRj03A" name="Underline nouns and noun phrases" guid="_matvgOB8Ed-aE9U0mRj03A">
    <sectionDescription>&lt;p>&#xD;
    If you have a textual specification or concept document, underlining the nouns and noun phrases can lead to the&#xD;
    identification of:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Objects&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Classes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Attributes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Actors&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You can also identify:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        synonyms&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        uninteresting objects&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    This is a common approach but is problematic in an incremental, spiral process. Problems arise because the increments&#xD;
    implement only a subset of the entire system. Unless the textual specification is organized around the use cases, it is&#xD;
    difficult to focus only on the nouns or noun phrases relevant to the specific use case under consideration.&#xD;
    Nevertheless, if you have a well-written textual specification and it is organized around the use cases, then the&#xD;
    strategy can be effective.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_oOy8QOB8Ed-aE9U0mRj03A" name="Identify Causal Agents" guid="_oOy8QOB8Ed-aE9U0mRj03A">
    <sectionDescription>Causal agents are things that cause results to occur; for example, a button on an elevator system &quot;causes&quot; the elevator to&#xD;
be selected and dispatched to the floor; the arrival of the elevator at the floor &quot;causes&quot; the elevator door and floor door&#xD;
to interlock; the resulting interlock &quot;causes' the doors to cycle open, and so on. Identification of causal streams can&#xD;
lead to the objects and classes that provide the cause and others that realize the effects.</sectionDescription>
  </sections>
  <sections xmi:id="_qLEbsOB8Ed-aE9U0mRj03A" name="Identify services to be performed" guid="_qLEbsOB8Ed-aE9U0mRj03A">
    <sectionDescription>Systems provide various services, some visible to an actor, some not. Every executing service is owned by a single instance&#xD;
and typed by a single class; some of these services result in the sequenced execution of other services in other instances.&#xD;
Following the service execution chain can identify the objects and classes that &quot;own&quot; and provide those services. This&#xD;
strategy can also lead to the identification of attributes by asking &quot;What information does this service need or produce?&quot;</sectionDescription>
  </sections>
  <sections xmi:id="_r2W40OB8Ed-aE9U0mRj03A" name="Identify events to be received" guid="_r2W40OB8Ed-aE9U0mRj03A">
    <sectionDescription>Events are related to services in that they can invoke the execution of services. The &quot;Identify events to be received&quot;&#xD;
strategy is very similar to the &quot;Identify services to be performed&quot; but may be more obvious in reactive systems - that is,&#xD;
systems which receive and react to events of interest. Every event is generated by a class and received and processed.</sectionDescription>
  </sections>
  <sections xmi:id="_tL5IYOB8Ed-aE9U0mRj03A" name="Identify information to be created or managed" guid="_tL5IYOB8Ed-aE9U0mRj03A">
    <sectionDescription>Data must be stored as attributes of classes, so the identification of data leads one to identify the class that creates,&#xD;
owns, manages, or destroys that data. This strategy can also identify services provided by the owner classes by asking &quot;how&#xD;
is this information used?&quot;</sectionDescription>
  </sections>
  <sections xmi:id="_vGraEOB8Ed-aE9U0mRj03A" name="Identify transactions" guid="_vGraEOB8Ed-aE9U0mRj03A">
    <sectionDescription>A transaction is the reification of an interaction between objects as an object itself. Transactions are used when an&#xD;
interaction is complex, state-full, or persist for a period of time and must be managed. Transactions are used in reliable&#xD;
message delivery, connection-oriented messaging, staged interactions, or whenever an interaction between objects must be&#xD;
remembered (such as in a deposit into a banking account).</sectionDescription>
  </sections>
  <sections xmi:id="_wE0dUOB8Ed-aE9U0mRj03A" name="Identify real-world things to be represented" guid="_wE0dUOB8Ed-aE9U0mRj03A">
    <sectionDescription>Systems must often represent real-world elements as interfaces, data representation, simulations, or resources. Physical&#xD;
devices (important enough to be a strategy on its own) are most often represented as interfaces to electronics, but may be&#xD;
simulated in some cases. Data representations stand in for some specific aspects of these real-world things; for example a&#xD;
banking customer class might hold the customer's name, bank ID, tax billing number, phone and address. Resources are&#xD;
represented as classes with a finite capacity of some kind; such as a list of available parts or a fuel tank with a&#xD;
specific quantity being held within its capacity. These are represented within the system as objects, typed by classes.</sectionDescription>
  </sections>
  <sections xmi:id="_xvNikOB8Ed-aE9U0mRj03A" name="Identify resources to be managed" guid="_xvNikOB8Ed-aE9U0mRj03A">
    <sectionDescription>Resources are objects that have finite capacity. They can represent physical elements (such a memory available, fuel in a&#xD;
fuel tank or missiles in a missile launcher) or abstractions (such as number of available connections or&amp;nbsp;number of&#xD;
awaiting messages) but they are represented as objects in the system.</sectionDescription>
  </sections>
  <sections xmi:id="_zDspQOB8Ed-aE9U0mRj03A" name="Identify physical devices" guid="_zDspQOB8Ed-aE9U0mRj03A">
    <sectionDescription>Physical devices are a special kind of real-world thing. Most commonly by far, physical devices are represented by&#xD;
interfaces; that is, a single object &quot;knows&quot; how to actually talk to the physical sensor or actuator; any object in the&#xD;
system that must access the physical device does so through this interface object. Sometimes, however, the physics (or&#xD;
other characteristics) of a physical device must be simulated, such as when the device is not yet available for&#xD;
integration, or when you're modeling physical properties, such as modeling a bullet's trajectory in a video game.</sectionDescription>
  </sections>
  <sections xmi:id="_0aIQsOB8Ed-aE9U0mRj03A" name="Identify key concepts and abstractions" guid="_0aIQsOB8Ed-aE9U0mRj03A">
    <sectionDescription>Key abstractions are the antithesis to physical devices; these are things that are conceptual, but nevertheless essential&#xD;
in the domain of discourse. For example, a track in a tracking application, an account in a banking application, a window&#xD;
in a GUI application, a thread in an operating system, a function in a compiler, etc. Every application domain has an&#xD;
interrelated set of concepts that must be represented as objects and classes.</sectionDescription>
  </sections>
  <sections xmi:id="_2LEp4OB8Ed-aE9U0mRj03A" name="Identify persistent data" guid="_2LEp4OB8Ed-aE9U0mRj03A">
    <sectionDescription>The Persistent Data strategy looks for data that is important to remember for long periods of time, possible between hard&#xD;
restarts of the system. Such data might be user names and passwords, configuration data, maps and geolocation data, etc.&#xD;
These data must be represented as objects and classes within the model.</sectionDescription>
  </sections>
  <sections xmi:id="_3ryOsOB8Ed-aE9U0mRj03A" name="Execute scenarios" guid="_3ryOsOB8Ed-aE9U0mRj03A">
    <sectionDescription>&lt;p>&#xD;
    The execute scenarios strategy is a personal favorite; it seeks to identify objects by walking through or executing use&#xD;
    case scenarios and adding objects (as lifelines) to the scenario to &quot;flush it out.&quot; The messages to the lifelines&#xD;
    become services provided by those objects, invoked either by calls (synchronous rendezvous) or event receptions&#xD;
    (asynchronous rendezvous). Lifelines (objects) are added as you walk through the scenario. When a message is sent&#xD;
    between objects, an association between them is drawn between then on a class diagram.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Scenarios may be walked through from the beginning or at any &quot;interesting&quot; part. This is an invaluable strategy for&#xD;
    identifying objects, services, and relations.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <purpose>The purpose is to identify structural elements, their relations, and their behavior that is essential for correctness.</purpose>
</org.eclipse.epf.uma:TaskDescription>
