<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-DtJAdAyg3sCvqvUlpAwsvw" name="creating_and_applying_implementation_mechanisms,_XFPAgFhVEd21tbtmum3VeQ" guid="-DtJAdAyg3sCvqvUlpAwsvw" changeDate="2009-02-22T21:05:47.281-0800" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    &lt;strong>Relationship among Design Mechanisms, Implementation Mechanisms and Idioms&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An implementation mechanism may utilize one or more language idioms in its realization. Idioms are specific to&#xD;
    programming languages and underlying runtime infrastructure used in a software project. Unlike design mechanisms,&#xD;
    idioms are not portable. Idioms describe how to solve particular programming issues using the features of the selected&#xD;
    language. Object lifecycle management, container iteration, object comparison, copying and memory management are&#xD;
    examples of idioms.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Selecting Implementation Mechanisms&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Think about the design problem in which you are involved, bearing in mind how design and implementation mechanisms help&#xD;
    solve creational, structural and behavioral problems. Make an inventory of the implementation mechanisms you have at&#xD;
    your disposal, if any. Review the documented problem space of each mechanism. Review information about each mechanism's&#xD;
    intent, benefits and liabilities. Understand variations of the mechanism you want to use.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Mechanisms are available from many sources, including:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Middleware product or component framework.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Operating systems.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Standalone&amp;nbsp;components.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Class libraries.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Legacy code.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Special purpose packages such as&amp;nbsp;GUI builders, Geographical Information System, DBMS, etc.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Books (for example,&amp;nbsp;patterns or platform specific tutorials)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Determine where to use existing implementation mechanisms in the inventory and where building new implementation&#xD;
    mechanisms are required.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Map Design Mechanisms to Implementation Mechanisms&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Initially, the mapping between design mechanisms and implementation mechanisms is likely to be less than optimal but it&#xD;
    will get the project running, identify risks, and trigger further investigations and evaluations. As the project&#xD;
    continues and participants gain more knowledge about the implementation environment, the mapping needs to be refined.&#xD;
    Proceed iteratively to refine the mapping between design and implementation mechanisms, eliminating redundant paths,&#xD;
    working both top-down and bottom-up.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;em>Working Top-Down&lt;/em>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    New and refined requirements put new emphasis on the design mechanisms needed via the analysis mechanisms needed. These&#xD;
    requirements might uncover additional characteristics of a design mechanism, forcing a split between mechanisms. There&#xD;
    is also a compromise among the system's complexity, reliability, maintainability and performance:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Too many different design mechanisms used in the same area make the system too complex and hard to maintain.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Too few design mechanisms can create performance and reliability issues for some implementation mechanisms that&#xD;
        stretch the limits of developer's ability to write effective, low-defect code.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    &lt;em>Working Bottom-Up&lt;/em>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Investigate the available implementation mechanisms. Find products that satisfy several design mechanisms at once, but&#xD;
    force some adaptation or repartitioning of your design mechanisms. Minimize the number of implementation mechanisms&#xD;
    used, but too few of them can also lead to performance or reliability issues. The trade-off is creating new code to&#xD;
    satisfy implementation mechanism needs.&lt;br />&#xD;
    &lt;br />&#xD;
    Because implementation mechanisms often come in bundles in off-the-shelf components (operating systems and middleware&#xD;
    products) some optimization based on cost, impedance mismatch, or uniformity of style will occur. In addition,&#xD;
    mechanisms often are inter-dependent, making clear separation of services into design mechanisms difficult.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Refinement continues over the life of the project and there are always compromises between:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        An exact 'fit' with the requirements of the clients of the design mechanism, in terms of the expected&#xD;
        characteristics.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The cost and complexity of having too many different implementation mechanisms to acquire and integrate.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The overall goal is always to have a simple set of mechanisms that give conceptual integrity, simplicity and elegance&#xD;
    to a large system. Conduct a search for the right components or build the components. You will often find that there is&#xD;
    no apparently suitable implementation mechanism for some design mechanism. This will trigger a search for the right&#xD;
    product or identify the need for in-house development. You may also find some unused implementation mechanisms in the&#xD;
    inventory.&lt;br />&#xD;
    &lt;br />&#xD;
    Consider the cost of acquisition for purchased components. For candidate implementation mechanisms, consider the cost&#xD;
    of acquisition or licensing, the maturity of the product, relationship with the vendor, support, etc, in addition to&#xD;
    purely technical criteria.&lt;br />&#xD;
    &lt;br />&#xD;
    Base the choice of implementation mechanisms on a good match for the technical characteristics and on the non-technical&#xD;
    characteristics such as cost. Some of the choices may be provisional and almost all have some risks attached to them&#xD;
    such as performance, robustness, and scalability. These are concerns requiring validation by evaluation, exploratory&#xD;
    prototyping, or inclusion in early versions of the architecture.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Applying Implementation Mechanisms&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Understand the structure and collaborations of an implementation mechanism before attempting to apply it. Valuable&#xD;
    examples include previous applications or documentation included with the mechanism.&lt;br />&#xD;
    &lt;br />&#xD;
    Integrating implementation mechanisms into an existing system might require rework of existing classes and addition of&#xD;
    new classes. The participants of a specific implementation mechanism need meaningful names within the context of the&#xD;
    software's problem domain. The participants have a specific role in realizing the mechanism in the software. Name the&#xD;
    methods and relationships for existing and new classes participating within the mechanism in a way that provides&#xD;
    meaning in the context of the software application and their role in the mechanism.&lt;br />&#xD;
    &lt;br />&#xD;
    Finally, implement any code to realize the mechanism in the software. Use the specific language and runtime idioms of&#xD;
    the environment to satisfy these requirements.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
