<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-zWJmMLcG-BKlBe_xNFUBeg" name="new_concept,_LknKAH3FEd2eJPu0NyCdUg" guid="-zWJmMLcG-BKlBe_xNFUBeg" changeDate="2008-09-30T15:02:54.122-0700" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Nodes, Processors and Devices&quot; name=&quot;Nodes, Processors and Devices&quot;>Nodes, Processors and Devices&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Processors and Devices are common stereotypes of Node. The distinction between the two may seem difficult to assess, as&#xD;
    many devices now contain their own CPUs. However, the distinction between processors and devices lies in the type of&#xD;
    software that executes on them. Processors execute programs/software that were explicitly written for the system being&#xD;
    developed. Processors are general-purpose computing devices which have computing capacity, memory, and execution&#xD;
    capability.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Devices execute software written that controls the functionality of the device itself. Devices are typically attached&#xD;
    to a processor that controls the device. They typically execute embedded software and are incapable of running&#xD;
    general-purpose programs. Their functionality is typically controlled by device-driver software.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Distribution Patterns&quot; name=&quot;Distribution Patterns&quot;>Distribution Patterns&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    There are a number of typical patterns of distribution in systems, depending on the functionality of the system and the&#xD;
    type of application. In many cases, the distribution pattern is informally used to describe the 'architecture' of the&#xD;
    system, though the full architecture encompasses this but also many more things. For example, many times a system will&#xD;
    be described as having a 'client-server architecture', although this is only the distribution aspect of the&#xD;
    architecture. This serves to highlight the importance of the distribution aspects of the system and the extent to which&#xD;
    they influence other architectural decisions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The distribution patterns described below imply certain system characteristics, performance characteristics, and&#xD;
    process architectures. Each solves certain problems but also poses unique challenges.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Client/Server Architectures&quot; name=&quot;Client/Server Architectures&quot;>Client/Server Architectures&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In so-called &quot;client/server architectures&quot;, there are specialized network processor nodes called &lt;b>clients&lt;/b>, and&#xD;
    nodes called &lt;b>servers&lt;/b>. Clients are consumers of services provided by a server. A client often services a single&#xD;
    user and often handles end-user presentation services (GUI's), while the server usually provides services to several&#xD;
    clients simultaneously; the services provided are typically database, security or print services. The &quot;application&#xD;
    logic&quot;, or the business logic, in these systems is typically distributed among both the client and the server.&#xD;
    Distribution of the business logic is called &lt;b>application partitioning&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In the following figure, Client A shows an example of a 2-tier architecture, with most application logic located in the&#xD;
    server. Client B shows a typical 3-tier architecture, with Business Services implemented in a Business Object Server.&#xD;
    Client C shows a typical web-based application.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;287&quot; alt=&quot;Diagram is described in the content.&quot; src=&quot;./resources/dpatt01.gif&quot; width=&quot;546&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Variations of Client-Server Architectures&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In traditional client/server systems, most of the business logic is implemented on clients; but some functionality is&#xD;
    better suited to be located on the server, for example functionality that often access data stored on the server. By&#xD;
    doing this, one can decrease the network traffic, which in most cases is quite expensive (it is an order of magnitude&#xD;
    or two slower than inter-process communication).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Some characteristics:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A system can consist of several different types of clients, examples of which include: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                User workstations&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Network computers&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Clients and servers communicate by using various technologies, such as CORBA/IDL, or RPC (remote-procedure call)&#xD;
        technologies.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A system can consist of several different types of servers, examples of which include the following: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                &lt;b>Database servers&lt;/b>, handling database machines such as Sybase, Ingres, Oracle, Informix.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                &lt;b>Print servers&lt;/b>, handling the driver logic such as queuing for a specific printer.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                &lt;b>Communication servers&lt;/b> (TCP/IP, ISDN, X.25).&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                &lt;b>Window Manager servers&lt;/b> (X).&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                &lt;b>File servers&lt;/b> (NFS under UNIX).&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;The 3-Tier Architecture&quot; name=&quot;The 3-Tier Architecture&quot;>The '3-Tier Architecture'&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The '3-tier Architecture' is a special case of the 'Client/Server Architecture' in which functionality in the system is&#xD;
    divided into 3 logical partitions: application services, business services, and data services. The 'logical partitions'&#xD;
    may in fact map to 3 or more physical nodes.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;268&quot; alt=&quot;Diagram is described in the content.&quot; src=&quot;./resources/3-tier.gif&quot; width=&quot;175&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Example of a 3-tier Architecture&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The logical partitioning into these three 'tiers' reflects an observation about how functionality in typical office&#xD;
    applications tends to be implemented, and how it changes. Application services, primarily dealing with GUI presentation&#xD;
    issues, tends to execute on a dedicated desktop workstation with a graphical, windowing operating environment. Changes&#xD;
    in functionality tends to be dictated often by ease of use or aesthetic considerations, essentially &lt;b>human&#xD;
    factors&lt;/b> issues.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Data services tend to be implemented using database server technology, which tends to execute on one or more&#xD;
    high-performance, high-bandwidth nodes that serve hundreds or thousands of users, connected over a network. Data&#xD;
    services tend to change when the representation and relationships between stored information changes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Business services reflect encoded knowledge of business processes. They manipulate and synthesize information obtained&#xD;
    from the data services, and provide it to the application services. Business services are typically used by many users&#xD;
    in common, so they tend to be located on specialized servers as well, though the may reside on the same nodes as the&#xD;
    data services.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Partitioning functionality along these lines provides a relatively reliable pattern for scalability: by adding servers&#xD;
    and re-balancing processing across data and business servers, a greater degree of scalability is achieved.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;The 'Fat Client Architecture'&quot; name=&quot;The 'Fat Client Architecture'&quot;>The 'Fat Client Architecture'&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The client is &quot;Fat&quot; since nearly everything runs on it (except in a variation, called the '2-tier architecture', in&#xD;
    which the data services are located on a separate node). Application Services, Business Services and Data Services all&#xD;
    reside on client machine; the database server will be usually on another machine.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;174&quot; alt=&quot;Diagram is described in the content.&quot; src=&quot;./resources/2-tier.gif&quot; width=&quot;166&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Traditional 2-tier or &quot;Fat Client&quot; Architecture&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    'Fat Clients' are relatively simple to design and build, but more difficult to distribute (they tend to be large and&#xD;
    monolithic) and maintain. Because the client machines tend to cache data locally for performance, local cache coherency&#xD;
    and consistency tend to be issues and areas warranting particular attention. Changes to shared objects located in&#xD;
    multiple local caches are difficult and expensive to coordinate, involving as they do network broadcast of changes.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Web Application&quot; name=&quot;Web Application&quot;>The 'Fat Server Architecture'&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    At the other end of the spectrum from the 'Fat Client' is the 'Fat Server' or 'Thin Client'. A typical example is the&#xD;
    web-browser application running a set of HTML pages, there is very little application in the client at all. Nearly all&#xD;
    work takes place on one or more web servers and data servers.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;174&quot; alt=&quot;Diagram is described in the content.&quot; src=&quot;./resources/dpatt04.gif&quot; width=&quot;166&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Web Application&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Web applications are easy to distribute, easy to change. They are relatively inexpensive to develop and support (since&#xD;
    much of the application infrastructure is provided by the browser and the web server). They may however not provide the&#xD;
    desired degree of control over the application, and they tend to saturate the network quickly if not well-designed (and&#xD;
    sometimes despite being well-designed).&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Distributed Client/Server&quot; name=&quot;Distributed Client/Server&quot;>Distributed Client/Server Architecture&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In this architecture, the application, business and data services reside on different nodes, potentially with&#xD;
    specialization of servers in the business services and data services tiers. A full realization of a 3-tier&#xD;
    architecture.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;The Peer-to-Peer Architecture&quot; name=&quot;The Peer-to-Peer Architecture&quot;>The Peer-to-Peer Architecture&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In the peer-to-peer architecture, any process or node in the system may be both client &lt;b>and&lt;/b> server. Distribution&#xD;
    of functionality is achieved by grouping inter-related services together to minimize network traffic while maximizing&#xD;
    throughput and system utilization. Such systems tend to be complex, and there is a greater need to be aware of issues&#xD;
    such as dead-lock, starvation between processes, and fault handling.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
