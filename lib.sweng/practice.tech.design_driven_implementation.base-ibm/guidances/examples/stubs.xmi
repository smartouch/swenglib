<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:GuidanceDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-Rej0XAtCjGhomuE-LK8mjg" name=",_z9RuwI5LEd2Wvsa4iN6Ysg" guid="-Rej0XAtCjGhomuE-LK8mjg" changeDate="2009-02-22T19:42:30.921-0800" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    Unless the stubs were constructed because the real component wasn't available yet, you should expect to retain them&#xD;
    past deployment. The tests they support will likely be important during product maintenance. Stubs, therefore, need to&#xD;
    be written to higher standards than throwaway code. While they don't need to meet the standards of product code - for&#xD;
    example, most do not need a test suite of their own - later developers will have to maintain them as components of the&#xD;
    product change. If that maintenance is too hard, the stubs will be discarded, and the investment in them will be lost.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Especially when they're to be retained, stubs alter component design. For example, suppose your component will use a&#xD;
    database to store key/value pairs persistently. Consider two design scenarios:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Scenario 1: The database is used for testing as well as for normal use&lt;/b>. The existence of the database needn't be&#xD;
    hidden from the component. You might initialize it with the name of the database:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;/p>&#xD;
&lt;pre>&#xD;
public Component(&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
String databaseURL&lt;/font>&lt;/b>) &#xD;
{&#xD;
try &#xD;
{  &#xD;
databaseConnection = DriverManager.getConnection(databaseURL);&#xD;
... &#xD;
} catch (SQLException e) {...}     &#xD;
}&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
And, while you wouldn't want each location that read or wrote a value to construct a SQL statement, you'd certainly have&#xD;
some methods that contain SQL. For example, component code that needs a value might call this component method: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
public String get(String key) &#xD;
{ &#xD;
try &#xD;
{     &#xD;
Statement stmt = databaseConnection.createStatement();&#xD;
ResultSet rs = stmt.executeQuery(&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
&quot;SELECT value FROM Table1 WHERE key=&quot; + key&lt;/font>&lt;/b>);           &#xD;
... &#xD;
} catch (SQLException e) {...} &#xD;
}&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
&lt;b>Scenario 2: For testing, the database is replaced by a stub.&lt;/b> The component code should look the same whether it's&#xD;
running against the real database or the stub. So it needs to be coded to use methods of an abstract interface: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
interface KeyValuePairs&lt;/font>&lt;/b> &#xD;
{ &#xD;
String &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
get&lt;/font>&lt;/b>(String key);&#xD;
void &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
put&lt;/font>&lt;/b>(String key, String value);&#xD;
}&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
Tests would implement &lt;b>KeyValuePairs&lt;/b> with something simple like a hash table: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
class FakeDatabase implements KeyValuePairs&lt;/font>&lt;/b>  &#xD;
{ &#xD;
Hashtable table = new Hashtable(); &#xD;
public String &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
get&lt;/font>&lt;/b>(String key) {return (String) table.get(key); } &#xD;
public void &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
put&lt;/font>&lt;/b>(String key, String value) {table.put(key, value); }&#xD;
}&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->When it is not being used in a test, the component would use an adapter object that&#xD;
converted calls to the &lt;font size=&quot;+0&quot;>KeyValuePairs&lt;/font> interface into SQL statements: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
class DatabaseAdapter implements KeyValuePairs&lt;/font>&lt;/b> &#xD;
{ &#xD;
private Connection databaseConnection; &#xD;
public DatabaseAdapter(String databaseURL) &#xD;
{     &#xD;
try &#xD;
{         &#xD;
databaseConnection = DriverManager.getConnection(databaseURL);&#xD;
...     &#xD;
} catch (SQLException e) {...} &#xD;
} &#xD;
public String &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
get&lt;/font>&lt;/b>(String key) &#xD;
{     &#xD;
try &#xD;
{         &#xD;
Statement stmt = databaseConnection.createStatement();         &#xD;
ResultSet rs = stmt.executeQuery(&quot;SELECT value FROM Table1 WHERE key=&quot; + key);         &#xD;
...     &#xD;
} catch (SQLException e) {...} &#xD;
} &#xD;
public void &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
put&lt;/font>&lt;/b>(String key, String value) {... }     &#xD;
}&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
Your component might have a single constructor for both tests and other clients. That constructor would take an object that&#xD;
implements &lt;font size=&quot;+0&quot;>KeyValuePairs&lt;/font>. Or it might provide that interface only for tests, requiring that ordinary&#xD;
clients of the component pass in the name of a database: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;!-- START NON-TRANSLATABLE -->&#xD;
&lt;pre>&#xD;
class Component &#xD;
{ &#xD;
&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
public&lt;/font>&lt;/b> Component(String databaseURL) &#xD;
{     &#xD;
this.valueStash = new DatabaseAdapter(databaseURL); &#xD;
} // For testing. &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
protected&lt;/font>&lt;/b> &#xD;
Component(KeyValuePairs valueStash) &#xD;
{     &#xD;
this.valueStash = valueStash; &#xD;
}     &#xD;
}&#xD;
&lt;!-- END NON-TRANSLATABLE -->&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
So, from the point of view of client programmers, the two design scenarios yield the same API, but one is more readily&#xD;
testable. (Some tests might use the real database and some might use the stub database.)</mainDescription>
</org.eclipse.epf.uma:GuidanceDescription>
