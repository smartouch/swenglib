<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-7kqjVJ48g0Xrkqdp6VQgDw" name="new_guideline,_hFB00HCbEd2LF8PmHMjllQ" guid="-7kqjVJ48g0Xrkqdp6VQgDw" changeDate="2008-09-15T14:00:30.817-0700" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    Like physical objects, tests can break. It's not that they wear down, it's that something's changed in their&#xD;
    environment. Perhaps they've been ported to a new operating system. Or-more likely-the code they exercise has changed&#xD;
    in a way that correctly causes the test to fail. Suppose you're working on version 2.0 of an e-banking application. In&#xD;
    version 1.0, this method was used to log in:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    &lt;strong>public boolean login (String username);&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    In version 2.0, the marketing department has realized that password protection might be a good idea. So the method is&#xD;
    changed to this:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>public boolean login (String username, String password);&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Any test that uses login will fail It won't even compile. Since not much useful work is possible at this point, not&#xD;
    many useful tests can be written without login. You might be faced with hundreds or thousands of failing tests.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    These tests can be fixed by using a global search-and-replace tool that finds every instance of&#xD;
    login(&lt;em>something&lt;/em>) and replaces it with login(&lt;em>something&lt;/em>, &quot;dummy password&quot;). Then arrange for all the&#xD;
    testing accounts to use that password, and you're on your way. Then, when marketing decides that passwords should not&#xD;
    be allowed to contain spaces, you get to do it all over again. This kind of thing is a wasteful burden, especially&#xD;
    when-as is often the case-the test changes aren't so easily made. There is a better way.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Suppose that the tests originally did not call the product's login method. Rather, they called a library method that&#xD;
    does whatever it takes to get the test logged in and ready to proceed. Initially, that method might look like this:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;codeSample&quot;>&#xD;
    public boolean testLogin (String username) {&lt;br />&#xD;
    return product.login(username);&lt;br />&#xD;
    }&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When the version 2.0 change happens, the utility library is changed to match:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;codeSample&quot;>&#xD;
    public Boolean testLogin (String username) {&lt;br />&#xD;
    return product.login(username, &quot;dummy password&quot;);&lt;br />&#xD;
    }&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    Instead of a changing a thousand tests, you change one method.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Ideally , all the needed library methods would be available at the beginning of the testing effort. In practice, they&#xD;
    can't all be anticipated-you might not realize you need a testLogin utility method until the first time the product&#xD;
    login changes. So test utility methods are often &quot;factored out&quot; of existing tests as needed. It is very important that&#xD;
    you perform this ongoing test repair, even under schedule pressure. If you do not, you will waste much time dealing&#xD;
    with an ugly and un-maintainable test suite. You might well find yourself throwing it away, or being unable to write&#xD;
    the needed numbers of new tests because all your available testing time is spent maintaining old ones.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    &lt;strong>Note&lt;/strong>: the tests of the product's login method will still call it directly. If its behavior changes,&#xD;
    some or all of those tests will need to be updated. (If none of the login tests fail when its behavior changes, they're&#xD;
    probably not very good at detecting defects.)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    &lt;strong>Another example&lt;/strong>&lt;br />&#xD;
    Suppose you're testing a compiler. Some of the first classes written define the compiler's internal parse tree and the&#xD;
    transformations made upon it. You have a number of tests that construct parse trees and test the transformations. One&#xD;
    such test might look like this:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;codeSample&quot;>&#xD;
	&lt;!-- START NON-TRANSLATABLE -->&#xD;
    /*&lt;br />&#xD;
    * Given&lt;br />&#xD;
    * while (i&amp;lt;0) { f(a+i); i++;}&lt;br />&#xD;
    * &quot;a+i&quot; cannot be hoisted from the loop because&lt;br />&#xD;
    * it contains a variable changed in the loop.&lt;br />&#xD;
    */&lt;br />&#xD;
    loopTest = new LessOp(new Token(&quot;i&quot;), new Token(&quot;0&quot;));&lt;br />&#xD;
    aPlusI = new PlusOp(new Token(&quot;a&quot;), new Token(&quot;i&quot;));&lt;br />&#xD;
    statement1 = new Statement(new Funcall(new Token(&quot;f&quot;), aPlusI));&lt;br />&#xD;
    statement2 = new Statement(new PostIncr(new Token(&quot;i&quot;));&lt;br />&#xD;
    loop = new While(loopTest, new Block(statement1, statement2));&lt;br />&#xD;
    expect(false, loop.canHoist(aPlusI))&#xD;
	&lt;!-- END NON-TRANSLATABLE -->&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    This is a difficult test to read. Suppose that time passes. Something changes that requires you to update the tests. At&#xD;
    this point, you have more product infrastructure to draw upon. In particular, you might have a parsing routine that&#xD;
    turns strings into parse trees. It would be better at this point to completely rewrite the tests to use it:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    loop=Parser.parse(&quot;while (i&amp;lt;0) { f(a+i); i++; }&quot;);&lt;br />&#xD;
    // Get a pointer to the &quot;a+i&quot; part of the loop.&lt;br />&#xD;
    aPlusI = loop.body.statements[0].args[0];&lt;br />&#xD;
    expect(false, loop.canHoist(aPlusI));&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Such tests will be much easier to understand, which will save time immediately and in the future. In fact, their&#xD;
    maintenance costs are so much lower that it might make sense to defer most of them until the parser is available.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There's a slight downside to this approach: such tests might discover a defect in either the transformation code (as&#xD;
    intended) or in the parser (by accident). So problem isolation and debugging may be somewhat more difficult. On the&#xD;
    other hand, finding a problem that the parser tests miss isn't such a bad thing.&lt;br />&#xD;
    There is also a chance that a defect in the parser might mask a defect in the transformation code. The chance of this&#xD;
    is rather small, and the cost from it is almost certainly less than the cost of maintaining the more complicated tests.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Focusing test improvement&lt;/strong>&lt;br />&#xD;
    A large test suite will contain some blocks of tests that don't change. They correspond to stable areas in the&#xD;
    application. Other blocks of tests will change often. They correspond to areas in the application where behavior is&#xD;
    changing often. These latter blocks of test will tend to make heavier use of utility libraries. Each test will test&#xD;
    specific behaviors in the changeable area. The utility libraries are designed to allow such a test to check its&#xD;
    targeted behaviors while remaining relatively immune to changes in untested behaviors.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For example, the &quot;loop hoisting&quot; test shown above is now immune to the details of how parse trees are built. It is&#xD;
    still sensitive to the structure of a while loop's parse tree (because of the sequences of accesses required to fetch&#xD;
    the sub-tree for a+i). If that structure proves changeable, the test can be made more abstract by creating a&#xD;
    fetchSubtree utility method:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;codeSample&quot;>&#xD;
    loop=Parser.parse(&quot;while (i&amp;lt;0) { f(a+i); i++; }&quot;);&lt;br />&#xD;
    aPlusI = fetchSubtree(loop, &quot;a+i&quot;);&lt;br />&#xD;
    expect(false, loop.canHoist(aPlusI));&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The test is now sensitive only to two things: the definition of the language (for example, that integers can be&#xD;
    incremented with ++), and the rules governing loop hoisting (the behavior whose correctness it's checking).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    &lt;strong>Throwing away tests&lt;/strong>&lt;br />&#xD;
    Even with utility libraries, a test might periodically be broken by behavior changes that have nothing to do with what&#xD;
    it checks. Fixing the test doesn't stand much of a chance of finding a defect due to the change; it's something you do&#xD;
    to preserve the test's chance of finding some other defect someday. But the cost of such a series of fixes might exceed&#xD;
    the value of the test's hypothetically finding a defect. It might be better to simply throw the test away and devote&#xD;
    the effort to creating new tests with greater value.&lt;br />&#xD;
    Most people resist the notion of throwing away a test-at least until they're so overwhelmed by the maintenance burden&#xD;
    that they throw all the tests away. It is better to make the decision carefully and continuously, test by test, asking:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    1. How much work will it be to fix this test well, perhaps adding to the utility library?&lt;br />&#xD;
    2. How else might the time be used?&lt;br />&#xD;
    3. How likely is it that the test will find serious defects in the future? What's been the track record of it and&#xD;
    related tests?&lt;br />&#xD;
    4. How long will it be before the test breaks again?&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    The answers to these questions will be rough estimates or even guesses. But asking them will yield better results than&#xD;
    simply having a policy of fixing all tests.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    Another reason to throw away tests is that they've become redundant. For example, early in development, there might be&#xD;
    a multitude of simple tests of basic parse-tree construction methods (the LessOp constructor and the like). Later,&#xD;
    during the writing of the parser, there will be a number of parser tests. Since the parser uses the construction&#xD;
    methods, the parser tests will also indirectly test them. As code changes break the construction tests, it's reasonable&#xD;
    to discard some of them as being redundant. Of course, any new or changed construction behavior will need new tests.&#xD;
    They might be implemented directly (if they're hard to test thoroughly through the parser) or indirectly (if tests&#xD;
    through the parser are adequate and more maintainable).&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
