<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-gdKmUHcSQMTkcydtEbBbQw" name="variability_analysis,_lP-BoFbREd6MCpkuB85p5g" guid="-gdKmUHcSQMTkcydtEbBbQw" changeDate="2009-09-23T20:48:50.375-0700" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    Many systems are built with very little foresight for incorporating changes resulting from new requirements.&#xD;
    Commonality and Variability Analysis creates a resilient design that is far more adaptive to change. This&#xD;
    is&amp;nbsp;achieved by avoiding the hard-coding or hard-designing of aspects of the domain that are anticipated to change&#xD;
    through the process of &lt;i>externalization&lt;/i>: separating out the more rapidly changing aspects of the functional and&#xD;
    structural aspects of the domain from the more stable, non-changing aspects. This technique&amp;nbsp;enables the system's&#xD;
    design to evolve and grow due to new requirements without intrusive alterations. During analysis, commonalities and&#xD;
    variabilities are modeled in terms of Type Hierarchies. Each point of variability is identified and externalized. For&#xD;
    example, the instances of variation such as &lt;em>Organizational Customer&lt;/em> and &lt;em>Individual Customer&lt;/em> can be&#xD;
    modeled as two realizations of a &lt;em>Customer Type&lt;/em> that can then be expanded as needed. The externalized type (for&#xD;
    example,&amp;nbsp;Customer Type) is associated with Customer Rules that span all customers and&amp;nbsp;enable refinements and&#xD;
    extensions to be made through specific Rule Types for each type of Customer.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The first step in the analysis is&amp;nbsp;identifying dependencies on Type from both functional (static) and process&#xD;
    (dynamic) perspectives. Identifying types of processes that rely on types of entities (functional) is a good heuristic&#xD;
    for the design refactoring:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Identify common elements of function and process (such as,&amp;nbsp;Reservation business process).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Separate changing from less changing aspects. Identify key types related to function and process that are&#xD;
        anticipated to change or are dependent (Reservation Type varies based on Customer Type&amp;nbsp;-- if Customer Type&#xD;
        changes, Reservation Type might change as a result).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Externalize the variations and create type hierarchies with known instances (Frequency Type is Preferred or&#xD;
        Regular, Party is Organizational or Individual).&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    These variability points are a key part of building systems that are resilient and adaptive. By externalizing&#xD;
    variability points, we can modify them without impacting the rest of the design. Thus, the ripple effect of change is&#xD;
    contained and constrained by the variability points. A UML class diagram showing this hierarchy provides a roadmap for&#xD;
    detailed design and ultimately, implementation.&#xD;
&lt;/p>The basic principles of&amp;nbsp;commonality and variability design are therefore: &lt;br />&#xD;
&lt;br />&#xD;
&lt;ol style=&quot;MARGIN-TOP: 0in&quot; type=&quot;1&quot;>&#xD;
    &lt;li>&#xD;
        Separate changing from non-changing aspects of a domain&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Separate the interface from implementation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Reify what changes. If some element of the domain is in constant flux, then it might be warranted to reify that&#xD;
        element into a class (or higher layer of reuse).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Build assets at each reuse level. The Reuse Levels are: base class, inheritance hierarchy, aggregation hierarchy,&#xD;
        cluster, framework, component, pattern, generic architecture.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Each reuse element has its own rules of behavior in addition to the meta-data necessary to reflectively and&#xD;
        adaptively self-describe the Reuse Element for run-time queries for service capabilities&#xD;
    &lt;/li>&#xD;
&lt;/ol></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
