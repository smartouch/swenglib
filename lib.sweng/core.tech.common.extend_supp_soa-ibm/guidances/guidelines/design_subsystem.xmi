<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-VG_JRGluyKt7F9WGOtScew" name="design_subsystem,_Mmdc0FIREd6lNtylJFsPIg" guid="-VG_JRGluyKt7F9WGOtScew" changeDate="2009-10-06T21:51:51.750-0700" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;font size=&quot;4&quot;>&lt;strong>Identifying Subsystems&lt;/strong>&lt;/font>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A complex analysis class is mapped to a &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/concepts/design_subsystem_47086B8E.html&quot; guid=&quot;_5inEwEo2Ed6D_7XK49c0nw&quot;>design subsystem&lt;/a> if it&amp;nbsp;seems to embody behavior that cannot be the&#xD;
    responsibility of a single design class acting alone. A complex design class might also become a subsystem, if it is&#xD;
    likely to be implemented as a set of collaborating classes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Subsystems also are&amp;nbsp;a good means of identifying parts of the system that are to be developed independently by a&#xD;
    separate team. If the collaborating design elements can be completely contained within a package along with their&#xD;
    collaborations, a subsystem can provide a stronger form of encapsulation than that provided by a simple package. The&#xD;
    contents and collaborations within a subsystem are completely isolated behind one or more interfaces, so that the&#xD;
    client of the subsystem is only dependent upon the interface. The designer of the subsystem is then completely isolated&#xD;
    from external dependencies.&amp;nbsp; The designer (or design team) is required to specify how the interface is realized,&#xD;
    but they are completely free to change the internal subsystem design without affecting external dependencies. In large&#xD;
    systems with largely independent teams, this degree of de-coupling combined with the architectural enforcement provided&#xD;
    by formal interfaces is a strong argument for the choice of subsystems over simple packages.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The design subsystem is used to encapsulate these collaborations in such a way that clients of the subsystem can be&#xD;
    completely unaware of the internal design of the subsystem, even as they use the services provided by the subsystem. If&#xD;
    the participating classes/subsystems in a collaboration interact only with each other to produce a well-defined set of&#xD;
    results, the collaboration and its collaborating design elements&amp;nbsp;need to&amp;nbsp;be encapsulated within a subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This rule can be applied to subsets of collaborations as well. Anywhere part or all of a collaboration can be&#xD;
    encapsulated and simplified, doing so will make the design easier to understand.&#xD;
&lt;/p>&#xD;
&lt;p dir=&quot;ltr&quot; style=&quot;MARGIN-RIGHT: 0px&quot;>&#xD;
    The following table provides hints to use to identify subsystems.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br />&#xD;
&lt;table title=&quot;&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;85%&quot; border=&quot;1&quot;>&#xD;
    &lt;tbody>&#xD;
        &lt;tr>&#xD;
            &lt;th id=&quot;&quot; scope=&quot;col&quot; abbr=&quot;&quot;>&#xD;
                &lt;p dir=&quot;ltr&quot; style=&quot;MARGIN-RIGHT: 0px&quot;>&#xD;
                    Hint&#xD;
                &lt;/p>&#xD;
            &lt;/th>&#xD;
            &lt;th id=&quot;&quot; scope=&quot;col&quot; abbr=&quot;&quot;>&#xD;
                &lt;p dir=&quot;ltr&quot; style=&quot;MARGIN-RIGHT: 0px&quot;>&#xD;
                    Details&#xD;
                &lt;/p>&#xD;
            &lt;/th>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;strong>Look for optionality&lt;/strong>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                If a particular collaboration (or sub-collaboration) represents optional behavior, enclose it in a&#xD;
                subsystem. Features which might be removed, upgraded, or replaced with alternatives&amp;nbsp;need to&amp;nbsp;be&#xD;
                considered independent.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;strong>Look to the user interface of the system.&lt;/strong>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                &lt;ol>&#xD;
                    &lt;li>&#xD;
                        If the user interface is relatively independent of the entity classes in the system (that&#xD;
                        is,&amp;nbsp;the two can and will change independently), create subsystems which are horizontally&#xD;
                        integrated.&amp;nbsp;Group related user interface boundary classes together in a subsystem, and group&#xD;
                        related entity classes together in another subsystem.&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        If the user interface and the entity classes it displays are tightly coupled (for example, a change&#xD;
                        in one triggers a change in the other), create subsystems which are vertically integrated.&amp;nbsp;&#xD;
                        Enclose related boundary and entity classes in common subsystem.&#xD;
                    &lt;/li>&#xD;
                &lt;/ol>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;strong>Look to the Actors&lt;/strong>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                &lt;ol>&#xD;
                    &lt;li>&#xD;
                        Separate functionality used by two different actors,&amp;nbsp;because each actor might independently&#xD;
                        change their requirements on the system.&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        Create subsystems to encapsulate access to an external system or device.&#xD;
                    &lt;/li>&#xD;
                &lt;/ol>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;strong>Look for coupling and cohesion between design elements&lt;/strong>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                Highly coupled or cohesive classes/subsystems collaborate to provide some set of services. Organize highly&#xD;
                coupled elements into subsystems, and separate elements along lines of weak coupling. In some cases, weak&#xD;
                coupling can be eliminated entirely by splitting classes into smaller classes with more cohesive&#xD;
                responsibilities, or repartitioning subsystems appropriately&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;strong>Look at substitution&lt;/strong>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                If there are several levels of service specified for a particular capability (example: high, medium and low&#xD;
                availability), represent each service level as a separate subsystem, each of which will realize the same&#xD;
                set of interfaces. By doing so, the subsystems are substitutable for one another.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;strong>Look at distribution&lt;/strong>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                &lt;span                 style=&quot;mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE&quot;>Although&#xD;
                there can be multiple instances of a particular subsystem, each executing on different nodes, in many&#xD;
                architectures it is not possible for a single instance of a component to be split across nodes. In the&#xD;
                cases where subsystem behavior must be split across nodes, it is recommended that you decompose the&#xD;
                subsystem into smaller subsystems (each representing a single component) with more restricted&#xD;
                functionality. &lt;span                 style=&quot;mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span>&#xD;
                Determine the functionality that must reside upon each node and create a new subsystem to 'own' that&#xD;
                functionality, distributing the responsibilities and related elements of the original subsystem&#xD;
                appropriately. &lt;span                 style=&quot;mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span>&#xD;
                The new subsystems are internal to the original subsystem.&lt;/span>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/tbody>&#xD;
&lt;/table>&lt;br />&#xD;
&lt;br />&#xD;
&lt;h3>&#xD;
    &lt;font size=&quot;4&quot;>&lt;strong>Modeling Subsystems&lt;/strong>&lt;/font>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Design Subsystems are modeled using UML components stereotyped as &amp;lt;&amp;lt;subsystem&amp;gt;&amp;gt;. This construct provides&#xD;
    the following modeling capabilities:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        can group classes to define a larger granularity part of a system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can separate the visible interfaces from internal implementation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can have execution at run-time&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Some other considerations are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Each Design Subsystem must be given a name and a short description.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The responsibilities of the original analysis class&amp;nbsp;need to&amp;nbsp;be transferred to the newly-created&#xD;
        subsystem, using the description of the subsystem to document the responsibilities&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    Subsystems that Represent Existing Products&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Where an existing product is one that exports interfaces,&amp;nbsp;that is,&amp;nbsp;operations (and perhaps receptions), but&#xD;
    otherwise keeps all details of implementation hidden, then it&amp;nbsp;can be modeled as a subsystem.&amp;nbsp; Examples of&#xD;
    products the system uses that you might be able to represent by a subsystem include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Communication software (middleware).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Database access support (RDBMS mapping support).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Application-specific products.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Some existing products such as collections of types and data structures (for example,&amp;nbsp;stacks, lists, and queues)&#xD;
    might be better represented as packages, because they reveal more than behavior, and it is the particular contents of&#xD;
    the package that are important and useful and not the package itself, which is simply a container.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Common utilities, such as math libraries, could be represented as subsystems if they simply export interfaces.&amp;nbsp;&#xD;
    Whether this is necessary or makes sense depends on the designer's judgment about the nature of the thing&#xD;
    modeled.&amp;nbsp; Subsystems are object-oriented constructs (as they are modeled components): a subsystem can have&#xD;
    instances (if the designer so indicates).&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When defining the subsystem to represent the product, also define one or more interfaces to represent the product&#xD;
    interfaces.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Subsystem Dependency Restrictions&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Design Subsystems (modeled as UML components with &amp;lt;&amp;lt;subsystem&amp;gt;&amp;gt; stereotype) differ from packages in their&#xD;
    semantics.&amp;nbsp; A subsystem provides behavior through one or more interfaces which it realizes. Packages provide no&#xD;
    behavior; they are simply containers of things which provide behavior.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The reason for using a subsystem instead of a package is that subsystems encapsulate their contents, providing behavior&#xD;
    only through their interfaces. The benefit of this is that, unlike a package, the contents and internal behaviors of a&#xD;
    subsystem can be changed with complete freedom so long as the subsystem's interfaces remain constant. Subsystems also&#xD;
    provide a 'replaceable&quot; design element.&amp;nbsp; Any two &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; components that realize the same&#xD;
    interfaces (or &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; component) are interchangeable.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In order to ensure that subsystems are replaceable elements in the model, a few rules need to be enforced:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A subsystem needs to&amp;nbsp;minimize exposing&amp;nbsp;its contents. Ideally, no element contained by a&#xD;
        subsystem&amp;nbsp;has 'public' visibility, and thus no element outside the subsystem depends on the existence of a&#xD;
        particular element inside the subsystem. Some exceptions are as follows: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                In some technologies, the externals of a subsystem cannot be modeled as a UML interface. For example, a&#xD;
                Java interface is modeled as a stereotyped class.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                The subsystem design might require exposing classes rather than UML interfaces. For example, a &quot;delegate&quot;&#xD;
                or &quot;access&quot; class can be used to hide a complex collaboration of other classes. While an ordinary package&#xD;
                could be used instead, a subsystem could be used in order to emphasize the intent to encapsulate behavior&#xD;
                and hide internal details.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        &lt;br />&#xD;
        When a subsystem's externals are not UML interfaces, it&amp;nbsp;often is helpful to have a diagram (for example named&#xD;
        &quot;External View&quot;) that shows the visible elements of the subsystem.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A subsystem&amp;nbsp;needs to&amp;nbsp;define its dependencies on subsystem interfaces (and publicly visible elements of&#xD;
        subsystems in the exceptional cases described above). In addition, a number of subsystems might share a set of&#xD;
        interfaces or class definitions in common, in which case those subsystems 'import' the contents of the packages&#xD;
        which contain the common elements. This is more common with packages in lower layers in the architecture, to ensure&#xD;
        that common definitions of classes which must pass between subsystems are consistently defined.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;font size=&quot;4&quot;>Subsystem Specification and Realization&lt;/font>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;3&quot;>&lt;strong>Definition&lt;/strong>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The &lt;a href=&quot;http://www.uml.org/&quot; target=&quot;_blank&quot;>UML 2.1.1 Superstructure specification&lt;/a> supports separate&#xD;
    definitions of component specification and realization.&amp;nbsp; Briefly, &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; denotes:&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A classifier that specifies a domain of objects without defining the physical implementation of those objects. For&#xD;
    example, a Component stereotyped by &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; will only have provided and required interfaces, and&#xD;
    is not intended to have any realizingClassifiers as part of its definition.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    And, &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; denotes:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A classifier that specifies a domain of objects and that also defines the physical implementation of those objects. For&#xD;
    example, a Component stereotyped by &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; will only have realizing Classifiers that implement&#xD;
    behavior specified by a separate &amp;lt;&amp;lt;specification&amp;gt;&amp;gt;Component.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The separation of specification and realization allows for two separate descriptions of the subsystem. The&#xD;
    specification serves as a contract that defines everything that a client needs to know to use the subsystem. The&#xD;
    realization is the detailed internal design intended to guide the implementer. If you&amp;nbsp;need to support multiple&#xD;
    realizations, create separate &quot;realization&quot; subsystems and draw a realization from each realization subsystem to the&#xD;
    specification subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;3&quot;>&lt;strong>When and how to use&lt;/strong>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the internal state and behavior of the subsystem&amp;nbsp;are relatively simple, it&amp;nbsp;can be sufficient to specify&#xD;
    the subsystem by its exposed interfaces, state diagrams to describe the behavior, and descriptive text.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For more complex internal state and behavior, analysis classes can be used to specify the subsystem at a high level of&#xD;
    abstraction. For large systems of systems, the specification of a subsystem might also include use cases.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Providing a detailed specification separate from the realization tends to be most useful in the following situations:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The subsystem realization's internal state or behavior is complex, and the specification needs to be expressed as&#xD;
        simply as possible in order for clients to use it effectively;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The subsystem is a reusable &quot;assembly component&quot; intended for assembly into a number of systems;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The subsystem's internals are expected to be developed by a separate organization;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Multiple implementations of the subsystem need to be created;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The subsystem is expected to be replaced with another version that has significant internal changes without changes&#xD;
        to the externally visible behavior.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Maintaining a separate specification takes effort, however, as one must ensure that the realization of the subsystem is&#xD;
    compliant with the specification. The criteria for when and if to create separate specification and realization classes&#xD;
    and collaborations&amp;nbsp;needs to&amp;nbsp;be clearly defined.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Dependencies&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A specification&amp;nbsp;needs to&amp;nbsp;define its dependencies. These are the interfaces and visible elements from other&#xD;
    subsystems and packages that must be available in all compliant realizations of the subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A realization might have additional dependencies, introduced by the designer or implementer. For example, there might&#xD;
    be an opportunity to use a utility component to simplify the implementation, but the use of this utility component is a&#xD;
    detail that need not be exposed to clients. These additional dependencies&amp;nbsp;can be captured on a separate diagram as&#xD;
    part of the realization.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Relationship to Implementation&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A fully detailed specification defines everything a client needs to use the subsystem. This means refining the exposed&#xD;
    interfaces and any publicly visible elements so that they are one-to-one with code. Leave&amp;nbsp;any analysis classes&#xD;
    that were introduced to specify the subsystem behavior&amp;nbsp;as high level abstractions,&amp;nbsp;because they are intended&#xD;
    to be independent of any subsystem's realizations.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
