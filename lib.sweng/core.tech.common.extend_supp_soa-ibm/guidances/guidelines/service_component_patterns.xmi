<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-6YkbwM5vWNKhJGISeAJl5A" name="service_component_patterns,_iQvsEGWmEd6Zd-lbA790BQ" guid="-6YkbwM5vWNKhJGISeAJl5A" changeDate="2009-10-29T08:36:56.781-0700" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In decomposing a service component into its constituent functional and technical components, we have delegated the&#xD;
    functionality provided by the service component to fulfill the subsystem's functional responsibilities. Functional&#xD;
    components supply the business functionality required, while technical components provide generic functionality such as&#xD;
    authentication, error handling, auditing, logging, etc which are operational and non-functional oriented.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A service model is a design-time artifact. As such, it does not deal directly with the implementation of services.&#xD;
    However, the actual implementation of a service or set of services is strictly performed by a service component's&#xD;
    realization of a service specification. The service specification provides the implementation contract; the technology&#xD;
    or techniques used to implement the service are irrelevant as long as the contract is fulfilled. In &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/concepts/service_oriented_architecture_956B2631.html&quot; guid=&quot;_xvH6UEo2Ed6D_7XK49c0nw&quot;>Concept: Service Oriented Architecture&lt;/a>, we introduced the following picture&#xD;
    demonstrating the relationship between the services we identify and the components and objects that provide the&#xD;
    implementation of these services.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 1.&amp;nbsp; Conceptual&amp;nbsp;abstraction hierarchy among&amp;nbsp;service layer, component layer, and object&#xD;
    layer&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&lt;img height=&quot;241&quot; alt=&quot;Diagram described in associated text&quot; src=&quot;./resources/co_soa_soa-01.gif&quot; width=&quot;241&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In this way, we see that a traditional&amp;nbsp;component design model can be used to capture the design of the component&#xD;
    and object layers, with implementation models and artifacts capturing details of the object layer and associated&#xD;
    implementation and deployment artifacts. Important aspects of the relationship between the service model and the&#xD;
    component design model are that the set of service specifications represent contracts that must be fulfilled,&#xD;
    operations identified on specifications must be implemented as-is, and that consumers of services are using this same&#xD;
    model to understand the interface and behavior of the services they expect to use. As such, there is a direct and in&#xD;
    general a one-to-one relationship between the service specification and some implementation artifact that acts as the&#xD;
    initial implementation entry point for the service.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For example, consider the following diagram of a service provider showing its delegation of interface operation&#xD;
    implementation to an internal component.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2.&amp;nbsp;&amp;nbsp;Delegation of a service provider's interface operation implementation to an internal&#xD;
    component&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&amp;nbsp;&lt;img height=&quot;177&quot; alt=&quot;&quot; src=&quot;./resources/serv_comp_pattrns_1.gif&quot; width=&quot;562&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The&amp;nbsp;service component needs to be directly traceable to the service model. The easiest way to accomplish this is&#xD;
    to make use of the fact that the service specification element is a UML Interface that can be realized by the service&#xD;
    component, thus ensuring its conformance to the structural specification. In this way we would get the following&#xD;
    result:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 3.&amp;nbsp; Realization of the service interface by a service component&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;142&quot; alt=&quot;&quot; src=&quot;./resources/serv_comp_pattrns_2.gif&quot; width=&quot;536&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It is now the responsibility of the component implementer to define a set of components and classes that provide the&#xD;
    behavior of the resulting component.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Kinds of Service Components&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    Functional Components&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The composition of these functional components into a larger-grained service component is not merely structural; it&#xD;
    also involves the definition of flow, that is, the collaboration of the functional components to provide functionality&#xD;
    to support the business processes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This step includes traditional OOAD activities. We have a focused and well-partitioned scope to direct the object&#xD;
    design. In traditional object-oriented design, we tend to create larger, more dependent object graphs, whereas if&#xD;
    subsystem analysis follows the identification of functional areas within the business, we have a very clearly defined&#xD;
    scope to focus on and direct our design energies towards. These results in a set of more loosely coupled object models&#xD;
    (class diagrams and sequence diagrams triggered by system use cases).&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Technical components&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;span style=&quot;mso-bidi-font-style: italic&quot;>The composition of technical components into larger-grained service&#xD;
    components occurs in the same fashion as functional components.&lt;/span> &lt;span     style=&quot;mso-bidi-font-style: italic&quot;>Technical components such as authentication, logging and reporting&amp;nbsp;can be used&#xD;
    across business processes. &lt;span style=&quot;mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span>These common components are needed to form the&#xD;
    infrastructure to support the functional components. &lt;span style=&quot;mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span>One of the key&#xD;
    variations across business processes is due to business rules as shown below&amp;nbsp;in&amp;nbsp;&lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/examples/enterprise_component_pattern_2336B1BC.html&quot; guid=&quot;_DS_TEGWpEd6Zd-lbA790BQ&quot;>Example: Enterprise Component Pattern&lt;/a>.&lt;/span> &lt;span     style=&quot;mso-bidi-font-style: italic&quot;>These variations are typically captured during Variation-Oriented Design.&lt;/span>&#xD;
&lt;/p>&lt;br class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot; />&#xD;
&lt;br />&#xD;
&lt;h3 style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    Service Component Patterns&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Having said that the service component simply realizes the service specification does not provide the implementer with&#xD;
    much assistance in going from a coarse-grained service definition to a set of fine-grained implementation classes and&#xD;
    artifacts required to provide the behavior of the service. In this regard, it is common to rely on patterns that&#xD;
    provide structure to the resulting service component, either as a starting framework or specific patterns to address&#xD;
    particular policy requirements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Five sample service component patterns are described in:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/examples/data_access_components_D88004BB.html&quot; guid=&quot;_-U1-EGWoEd6Zd-lbA790BQ&quot;>Example: Data Access Components&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/examples/base_service_component_pattern_EBED8518.html&quot; guid=&quot;_n7JDEGWmEd6Zd-lbA790BQ&quot;>Example: Base Service Component Pattern&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/examples/single_operation_service_component_pattern_CA1BB153.html&quot; guid=&quot;_tIoboGWmEd6Zd-lbA790BQ&quot;>Example: Single Operation Service Component Pattern&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/examples/mediated_operation_service_component_pattern_42FB2E94.html&quot; guid=&quot;_yzieEGWoEd6Zd-lbA790BQ&quot;>Example: Mediated Operation Service Component Pattern&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/examples/enterprise_component_pattern_2336B1BC.html&quot; guid=&quot;_DS_TEGWpEd6Zd-lbA790BQ&quot;>Example: Enterprise Component Pattern&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The choice of pattern is driven by non-functional requirements, architectural and design constraints, and other&#xD;
    organizational factors.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
