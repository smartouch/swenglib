<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-p9nmhgFQXtr1nhL0g_KuZw" name="new_concept,_SfOYMGtFEd6dX9uDBR7y4Q" guid="-p9nmhgFQXtr1nhL0g_KuZw" changeDate="2009-10-29T08:39:28.609-0700" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The notion of stateful and stateless components is particularly important in the development of distributed&#xD;
    applications and systems, although it has only recently tended to become part of the common vocabulary. Essentially,&#xD;
    the notion is that if two components or services are communicating and there is some state managed by the server&#xD;
    component for the duration of the conversation with the client, it is possible for a crash in the server component (or&#xD;
    network failure) to mean that the client is unable to complete the conversation and must start over. Also, it makes the&#xD;
    redirecting of client requests to one of a set of components harder unless the set of components share some common&#xD;
    store for the state of the conversation. This has become a well known issue in the development of Web applications&#xD;
    where its state is carefully managed so as to be avoided where possible and managed either by the client, by the&#xD;
    conversation itself (passing the state in each message), or in carefully designed stateful server-side components. For&#xD;
    example, the common example for stateful Web interaction is the shopping cart. Users will expect that the shopping cart&#xD;
    persists while they briefly walk away from the computer, but how is this accomplished with 100,000 concurrent users?&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Now, this is not to say that stateful components are inherently bad, they just represent a possible area of performance&#xD;
    and resilience failure unless carefully managed and developed to more rigorous standards. In fact, all business&#xD;
    applications contain services which by their very nature manage or represent entities that are inherently stateful or&#xD;
    contain services which must be accessed in certain logical sequences. In fact the JEE architecture defines separate&#xD;
    Stateless and Stateful Session Beans to explicitly denote these issues and defines certain restrictions on stateful&#xD;
    components. This brings us to a simple classification for stateful services, the reasons why we cannot avoid them in&#xD;
    the first place. A service might have to be stateful for one of the following reasons:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        &lt;b>The Service Holds State on behalf of the Client&lt;/b>; this is the shopping-cart example. Somehow, some data has&#xD;
        to be persisted between calls between client and the service, this data is part of the conversation, and so,&#xD;
        without care, it can bind a client to a given server resource.&#xD;
    &lt;/p>&lt;b>The Service Manages a Stateful Resource&lt;/b>; in this case the service tends to manage a set of resources or&#xD;
    entities, each of which has state. For example a customer order has state, a network switch has state, and so&#xD;
    on.&amp;nbsp;The interface for a service that manages that object by closing or deferring an order or rebooting a switch is&#xD;
    changing the state of a particular entity. &#xD;
    &lt;p>&#xD;
        &lt;b>The Service Has a Stateful Protocol&lt;/b>; in this case the service has some logical ordering to the operations it&#xD;
        provides. For example it has login(), dostuff() and logoff() operations, which we can deduce means that you cannot&#xD;
        call the dostuff() or logoff() operation unless the login() operation is called.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Another form of state which is found in many component architectures, but is not applicable in the services world, is&#xD;
    the notion of transactional state. It is possible in a component world to denote that a get() and update() method on a&#xD;
    component&amp;nbsp;can be called by a client within the scope of a transaction created and maintained by the client. The&#xD;
    update() method is assumed to change some underlying transactional store. This almost always requires the intervention&#xD;
    of the middleware platform to coordinate the transactions and ensure that methods requiring transactions are called by&#xD;
    a client with an open transaction. For services, it is not considered appropriate or desirable to follow a model where&#xD;
    transactions in the classic two-phase commit sense are held open over a number of service invocations. Now, standards&#xD;
    are being developed for transactions across service invocations, but they follow a fundamentally different paradigm&#xD;
    (compensation) and are supported differently by middleware platforms.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The most obvious technique, which was hinted at above, for the successful development of stateful services is to&#xD;
    externalize service state, thus making it not only explicit that the service has state, but that this state can be&#xD;
    identified as part of the service specification. This is discussed for the two classes of stateful service below.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Persistent Conversation State&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This is a case where the easiest advice is to avoid the situation in the first place. Wherever possible, if a design&#xD;
    calls for the management of state during a conversation between a service and its consumers, it would be best to try to&#xD;
    decide if another approach can be taken. If not, externalize this state by passing all of the required state data&#xD;
    between service and consumer with each message making up the entire conversation. This approach might mean that the&#xD;
    sizes of the messages are significantly increased, but the service itself is now entirely stateless. Another approach&#xD;
    is to carry a conversation identifier within each message and persist all conversation state into a permanent store&#xD;
    such as a database. While this has significant performance consequences on the server side, it&amp;nbsp;can be countered&#xD;
    against the network and client performance saved with the smaller messages.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    One of the primary purposes of making these services stateless is to be able to provide a set of identical services&#xD;
    that can service any request using load-balancing techniques to distribute clients. This load balancing is possible if&#xD;
    all state is completely externalized or persisted in a common store.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Managing Stateful Resources&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In this case, we look at the management of resources themselves that have explicit state. In fact, that state is an&#xD;
    important aspect of the resource. It might be that we can describe the state of the resource, the customer order, or&#xD;
    network switch mentioned above using a state machine, describing not only the valid states, but also the manner in&#xD;
    which the operations provided by the service affect the state of the underlying resource(s).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However we accomplish this description, it is important to realize that this state is an intrinsic part of the&#xD;
    resource. However, it might not be explicitly expressed in the information model representing it.&amp;nbsp;Where we are&#xD;
    managing any set of entities, we have to be able to identify any individual resource that we are acting upon, whether&#xD;
    or not it has an explicit identifier.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Where a service represents the access to, or query of, the state of a physical entity such as a network switch or a&#xD;
    process-control element, it is not possible to consider externalizing the state of the entity. The state of a valve is&#xD;
    only known by querying the valve. Although we can construct and reply with a message describing the current state of&#xD;
    the valve, this is not a permanent situation. The state of the valve can change during transmission or processing of&#xD;
    this message.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In the Web services area, there is a set of emerging standards known as the Web Services Resource Framework (WSRF)&#xD;
    which discusses patterns of stateful services and approaches to the encoding of state, particularly in the case of&#xD;
    services representing the management of stateful resources. For more information, see the &lt;a href=&quot;http://www.ibm.com/developerworks/library/ws-resource/&quot;>&lt;i>IBM WS-ResourceFramework site&lt;/i>&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Stateful Service Specifications&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The example mentioned above involves a service that has some logical sequencing to the operations it provides. Many&#xD;
    services will provide interfaces of this form. In some cases, this relates back to stateful resources except that in&#xD;
    that case, the ordering of the operations is based on the state of the managed resource. In this case, the ordering is&#xD;
    based on the conversation itself. The following example demonstrates a service specification that has some associated&#xD;
    protocol, first the structural specification and then a state machine is shown that describes the behavioral&#xD;
    specification.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 1.&amp;nbsp; ServiceInterface and structure operations specification&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp; &lt;img height=&quot;167&quot; alt=&quot;&quot; src=&quot;./resources/soa_svce_state-1a.gif&quot; width=&quot;159&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Purchase Order can be in one of the states &lt;i>{Open, Canceled, Fulfilled, Closed}&lt;/i> and changes state based on&#xD;
    the operations provided on the specification above. We also denote that in the case of the self transition on the state&#xD;
    Open, we&amp;nbsp;perform the OrderChanged operation, sending notifications of the change.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2.&amp;nbsp; State model for the ServiceInterface&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img height=&quot;275&quot; alt=&quot;&quot; src=&quot;./resources/soa_svce_state-02.gif&quot; width=&quot;365&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In many cases where services are developed all within a single business and technical scope, detailed behavioral&#xD;
    specifications might not be developed, or they will be described less formally in text. Where services are exposed&#xD;
    outside of such a scope, for example exposed between partitions, they represent a logical specification for interaction&#xD;
    between partitions and need to&amp;nbsp;be developed in far more detail. Also, detailed specifications enable more&#xD;
    efficient and effective reuse by consumers.&amp;nbsp;&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
