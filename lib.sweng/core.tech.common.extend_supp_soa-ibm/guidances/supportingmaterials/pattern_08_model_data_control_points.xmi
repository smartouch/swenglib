<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-79OmzOt3oI5bgB-yE9zRqQ" name="pattern_08_model_data_control_points,_mCnegHobEd6spLUpguTNDw" guid="-79OmzOt3oI5bgB-yE9zRqQ" changeDate="2009-08-08T14:24:56.021-0700" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    Context&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Most software systems that exist in an enterprise store data using some sort of persistence technology. Normally, but&#xD;
    not always, this is a relational database.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    No matter what the persistence technology, there are some element-level artifacts where the data is stored (for&#xD;
    example, a table in a relational database or an object in an object database). We consider that element-level artifact&#xD;
    to be&amp;nbsp;controlled by a software component if the only thing that is allowed to access the state it contains is that&#xD;
    software component.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Problem&#xD;
&lt;/h3>Not having clear data&amp;nbsp;control points&amp;nbsp;makes it impossible to ensure data encapsulation.&lt;br />&#xD;
&lt;h3>&#xD;
    Forces&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        It is difficult to know which component has encapsulated a specific data item.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        It is difficult to know what data items a component is responsible for.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        For a given component and data item, it is difficult to know whether the component implementation can access the&#xD;
        data item directly or whether the component has to access it through the interface of another component.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    Solution&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Assign data&amp;nbsp;control point&amp;nbsp;to &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/concepts/participant_soaml_1A392457.html&quot; guid=&quot;_zL3kgFbAEd6MCpkuB85p5g&quot;>Participants&lt;/a> &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/termdefinitions/service_provider.supp_soa_478061A7.html&quot; guid=&quot;_ewRWAIRSEd6jqtIeWlQI8A&quot;>&lt;/a>that provide &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend-ibm/guidances/termdefinitions/atomic_service_1B031A6D.html&quot; guid=&quot;_RmMI4IQnEd6pOcahJ5wBfA&quot;>atomic business application services&lt;/a>. Model this data&amp;nbsp;control point&amp;nbsp;using&#xD;
    information types.&amp;nbsp; For each such Participant we create an information type to represent each of the data items&#xD;
    that it manages.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        These information types are black box representations of the state that the Participant owns.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        By&amp;nbsp;control we mean that the Participant has exclusive access to the data instances in the data structure&#xD;
        (internal, white box) that matches the information type (external, black box).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Information types are very useful when using pre-conditions and post-conditions to describe the behavior of service&#xD;
        operations. In other words, the pre-conditions and post-conditions describe changes to the state owned by the&#xD;
        Participant in terms of the info types.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Information types can be (and should be) derived from domain types.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        It is not uncommon for more than one information type, each belonging to a different Participant, to be derived&#xD;
        from the same domain type. This is especially common when one Participant only has to store a reference to the&#xD;
        identity of a certain business thing, while another Participant persists actual instances of the thing.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    Rationale&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Understanding data&amp;nbsp;control points&amp;nbsp;is very important in our service architecture. Modeling info types to&#xD;
    represent the data controlled by each Participant means that:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        We can now tell which component has encapsulated a specific data item by checking to see which info types are&#xD;
        derived from the domain type, and then checking which Participant owns the info type.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To understand what data items a component is responsible for, we look at which info types its Participant controls.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To determine whether a component implementation can access a data item directly, verify whether the corresponding&#xD;
        info type is controlled by its Participant.&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
