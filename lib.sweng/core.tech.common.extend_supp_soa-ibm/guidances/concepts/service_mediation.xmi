<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-JFzHGsGU0hIHEtzKqMUQfg" name="service_mediation,_iEqOcGtlEd6dX9uDBR7y4Q" guid="-JFzHGsGU0hIHEtzKqMUQfg" changeDate="2009-10-29T08:19:05.906-0700" version="7.5.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Mediation is the act of intervention between conflicting parties to promote reconciliation or compromise. In&#xD;
    particular, three common forms of reconciliation are required in distributed systems in general and service-oriented&#xD;
    solutions in particular.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Interface mediation&lt;/b>; in object- or component-based systems interface, mediation is the change between&#xD;
        operation definitions between sender and receiver. In a service-oriented solution, this is seen as a mismatch in&#xD;
        message content/schema between sender and receiver.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Protocol mediation&lt;/b>; most common object- or component-based solutions tend to be based around a common&#xD;
        protocol or set of protocols for communication. In service-oriented solutions, a mix of protocols across the entire&#xD;
        solution is common and it is one of the advantages of the architecture. To communicate between services, messages&#xD;
        will have to span different protocols between sender and receiver.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Operation mediation&lt;/b>; this form of mediation might also look familiar to developers. It is related to the&#xD;
        common &lt;i>strategy pattern&lt;/i>. A component is able to select between one of a set of implementations of a&#xD;
        particular service or operation based on runtime parameters or content of the request. This is also known as&#xD;
        content-based routing.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    An increasing number of middleware platforms enable developers to implement advanced mediation without having to&#xD;
    develop explicit mediation components. In this case, as the middleware detects mismatches in data structure or&#xD;
    communications protocols, it can perform the mediation in its runtime. It is also possible for these platforms to&#xD;
    provide mediators that act as switches based on message content and business rules to select the correct implementation&#xD;
    of a given consumer request.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Data_Mediation&quot; name=&quot;Data_Mediation&quot;>Data Mediation in Activities&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In terms of connecting services where the definitions of messages do not match or the messages require transformation&#xD;
    between sender and receiver, it is possible to use a capability provided by UML 2.0 Activities to denote the&#xD;
    transformation between the sender and receiver. This capability, the association of a UML 2.0 Behavior to an ObjectFlow&#xD;
    between two Actions, allows for the identification of a reusable transformation behavior that can turn one message into&#xD;
    another (specifically from the UML 2.0 specification &lt;i>Changes or replaces data tokens flowing along edge&lt;/i>).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The transformation is a reusable element.&amp;nbsp;It can be identified to transform one message type to another and then&#xD;
    be used wherever needed in mediating messages between a sending and receiving service.&amp;nbsp;Although the UML does&#xD;
    provide a set of actions for navigating, reading, and updating a structure, these are relatively complex and might&#xD;
    prove too hard to use in defining transforms. It is expected that the transform&amp;nbsp;either will link to a more compact&#xD;
    representation (consider the XSL/T language) or a new way of expressing UML actions needs to be provided.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Data mediation&amp;nbsp;also can be treated as a concrete pattern of service iteration. For example, there is an explicit&#xD;
    mediation service responsible for the implementation of one or more data transformations. In this case, the mediator&#xD;
    has to respond to messages sent by the consumer, transform the message, and pass it on to the service, as shown below.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 1.&amp;nbsp;&amp;nbsp;Data mediation using an explicit mediation service&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;150&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;./resources/soa_svce_mediation-04.gif&quot;     width=&quot;326&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Protocol_Mediation&quot; name=&quot;Protocol_Mediation&quot;>Protocol Mediation on Service Gateways&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Mediation of protocol is well understood and supported explicitly in the service model. As the protocol information is&#xD;
    specified as the binding for a service channel, it is possible to introduce&amp;nbsp;additional&#xD;
    &amp;lt;&amp;lt;ServicePoint&amp;gt;&amp;gt; model elements that alter the protocol specification. For example, in the following&#xD;
    composite structure diagram you see two partitions, one for Web-facing services and one for internal services, and&#xD;
    there is a service channel between the partitions with a binding of &quot;HTTP-SOAP&quot;, something that is common for&#xD;
    Web-facing services.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2.&amp;nbsp; Mediation of protocol between service partitions&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;125&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;./resources/soa_svce_mediation-01.gif&quot;     width=&quot;203&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The issue is that, to support the required level of performance and other non-functional requirements, all&#xD;
    communication within the internal partition takes place over platform-specific protocols. The following diagram shows&#xD;
    how a service is connected to the ServicePoint (or service gateway)&amp;nbsp;&quot;Port : ISvcTwo&quot; using the Java RMI protocol,&#xD;
    but how is it then that the Web partition connects to the same&amp;nbsp;service gateway using HTTP-SOAP?&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 3.&amp;nbsp; Details of the internal partition, using high-performance transport protocol&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&lt;img height=&quot;132&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;./resources/soa_svce_mediation-02.gif&quot;     width=&quot;348&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The answer is that the service gateway itself can mediate the protocol by converting message structures and invocations&#xD;
    from one format to another. This is common functionality usually provided by middleware such as Object Request Brokers&#xD;
    (ORBs), Message Brokers, or Enterprise Service Buses. In fact, it would be possible to generate from the model above to&#xD;
    such middleware if required, or to reify &quot;Port : ISvcTwo&quot; as a service in its own right which takes calls from the Web&#xD;
    partition and resends them to the enclosed services.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Again, it is possible for the mediation to be modeled explicitly as a service that exposes the correct interface with&#xD;
    the consumer-side binding and delegates implementation to the provider service with a different binding.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Invocation_Mediation&quot; name=&quot;Invocation_Mediation&quot;>Invocation Mediation using Service Composition&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    It is common to define a structure where one service&amp;nbsp;depends on another service for some operation. However, the&#xD;
    actual service which will be called for any particular request is dependent on details embedded in the request, who the&#xD;
    requester is, and business rules applied using this information. The commonly given example for this is a customer&#xD;
    request, where the receiving service might choose one of two implementations based on the level of the customer. For&#xD;
    example, customers who are known to spend more money might get preferential treatment.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 4.&amp;nbsp;&amp;nbsp;Mediation using rules-driven service composition&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;109&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;./resources/soa_svce_mediation-03.gif&quot;     width=&quot;157&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As we described earlier, it is important in this kind of mediation to try to externalize the rules used to choose&#xD;
    between one or more providers of the actual operation implementation. In the diagram above, we show this as a rule&#xD;
    component attached to the mediating service. Obviously it is possible to build the solution as a set of services where&#xD;
    the mediator, rules, and all implementers are separate services. This can be seen below.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 5.&amp;nbsp; Implementation of mediation solution using separate mediator, rules, and implementer service&#xD;
    providers&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;420&quot; alt=&quot;&quot; src=&quot;./resources/serv_mediation_1.gif&quot; width=&quot;600&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Here we have a CustomerMediation &quot;wrapper&quot; Participant which assembles the service provider, rules, and requesting&#xD;
    Participants (see &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.tech.common.extend_supp_soa-ibm/guidances/examples/participant_soaml_DAFEB6B7.html&quot; guid=&quot;_uO9JIFbBEd6MCpkuB85p5g&quot;>Example: Participant (SoaML)&lt;/a>&amp;nbsp;for an example of this usage).&amp;nbsp; The&#xD;
    collaboration between the three assembled Participants is shown below.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 6.&amp;nbsp; Collaboration between services in the service composition mediation solution&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;357&quot; alt=&quot;&quot; src=&quot;./resources/serv_mediation_2.gif&quot; width=&quot;506&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Again, it is possible that this kind of content-based or rule-based routing of messages can be accomplished by the&#xD;
    middleware platform chosen as part of the solution architecture.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
