<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:GuidanceDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-mkq2xSIewR9jGP_UIwBE5A" name="service_contract_soaml,_RucNoFbPEd6MCpkuB85p5g" guid="-mkq2xSIewR9jGP_UIwBE5A" changeDate="2009-10-29T08:54:30.687-0700" version="7.5.0">
  <copyrightStatement href="uma://_4eYbIEcWEd6GBq2DuQ5crg#_cg5P8Lg9Ed6PrITAH4wF_w"/>
  <mainDescription>&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>In the context of services modeling, ServiceContracts&amp;nbsp;can be used to model the specification for a&#xD;
    specific service. A ServicesArchitecture&amp;nbsp;then can be used to model the requirements for a collection of&#xD;
    participants that provide and consume services defined with service contracts.&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>When modeling the requirements for a particular service, a ServiceContract captures an&#xD;
    agreement between the roles played by consumers and providers of the service, their capabilities and needs, and the&#xD;
    rules for how the consumers and providers must interact. The roles in a ServiceContract are typed by Interfaces that&#xD;
    specify Operations and events that comprise the choreographed interactions of the services. A ServiceInterface may&#xD;
    fulfill zero or more ServiceContracts to indicate the requirements it fulfills but they are usually&#xD;
    one-one.&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>Figure 1 presents an example of a ServiceContract. The orderer and order processor&#xD;
    participate in the contract.&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 1.&amp;nbsp; An OrderingService ServiceContract&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&lt;img height=&quot;153&quot; alt=&quot;&quot; src=&quot;./resources/servicecontract_example_1.gif&quot; width=&quot;538&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>The service contract diagram shows a high level &quot;business view&quot; of services but includes&#xD;
    ServiceInterfaces as the types of the roles to ground the business view in the required details. While two roles are&#xD;
    shown in the example, a ServiceContract&amp;nbsp;can have any number of roles. Identification of the roles can be augmented&#xD;
    with a behavior, such as the one shown in Figure 2. Real-world services&amp;nbsp;typically are long-running,&#xD;
    bi-directional, and asynchronous. This real-world behavior shows the information and resources that are transferred&#xD;
    between the service provider and consumer.&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2.&amp;nbsp; Behavior diagram documenting a ServiceContract protocol&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp; &lt;img height=&quot;299&quot; alt=&quot;&quot; src=&quot;./resources/servicecontract_example_2.jpg&quot; width=&quot;476&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>The above behavior (a UML interaction diagram) shows when and what&#xD;
    information is transferred between the parties in the service. In this case a fulfillPurchaseOrder message is sent from&#xD;
    the orderer to the order processor, and the order processor eventually responds with either a shipment schedule or an&#xD;
    order-rejected response. The service interfaces that correspond to the above types are shown in Figure&#xD;
    3.&lt;/font>&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 3.&amp;nbsp; ServiceInterfaces involved in the behavior&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&lt;img height=&quot;195&quot; alt=&quot;&quot; src=&quot;./resources/servicecontract_example_3.jpg&quot; width=&quot;528&quot; />&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>Figure 4 illustrates the concept of&amp;nbsp;compound services.&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 4.&amp;nbsp; A ServiceContract for a compound service&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&lt;img height=&quot;244&quot; alt=&quot;&quot; src=&quot;./resources/servicecontract_example_4.gif&quot; width=&quot;594&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>Real-world services&amp;nbsp;often are complex and are made up of simpler services as&#xD;
    &quot;building blocks.&quot; Using services as building blocks is a good design pattern, because it can decouple finer grain&#xD;
    services and make them reusable across a number of service contracts. Finer grain services&amp;nbsp;can then be delegated&#xD;
    to internal actors or components for implementation. Above is an example of a compound ServiceContract composed of&#xD;
    other, nested, ServiceContracts. This pattern is common when defining enterprise level ServicesArchitectures, which&#xD;
    tend to be more complex and span an extended process lifecycle. The purchasing ServiceContract is composed of 2 more&#xD;
    granular ServiceContracts: the &quot;Ordering Service&quot; and the &quot;Invoicing Service.&quot; The buyer is the &quot;orderer&quot; of the&#xD;
    ordering service and the &quot;invoice receiver&quot; of the invoicing service. The &quot;Seller&quot; is the &quot;Order processor&quot; of the&#xD;
    ordering service and the &quot;invoicer&quot; of the invoicing service. ServiceContracts&amp;nbsp;can be nested to any level using&#xD;
    this pattern. The purchasing service defines a new ServiceContract by piecing together these other two&#xD;
    services.&amp;nbsp;It is common in a compound service for one role to initiate a sub-service but then to be the client of&#xD;
    the next.&amp;nbsp; There is no expectation that all the services must go the same direction. This allows for long-lived,&#xD;
    rich, and asynchronous interactions between participants in a service.&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>Do not confuse a compound ServiceContract&amp;nbsp;with a service that is implemented by&#xD;
    calling other services, such as might be specified with a Participant ServicesArchitecture and/or implemented with&#xD;
    BPEL. A compound ServiceContract defines a more granular ServiceContract based on other ServiceContracts.&lt;/font>&lt;/font>&#xD;
    This is shown in Figure 5.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 5.&amp;nbsp; A compound service, realized using&amp;nbsp;subsidiary ServiceContracts and ServiceInterfaces with&#xD;
    ports&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&amp;nbsp;&lt;img height=&quot;349&quot; alt=&quot;&quot; src=&quot;./resources/servicecontract_example_5.jpg&quot; width=&quot;594&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>A compound service has service interfaces with ports, each port representing its role in&#xD;
    the larger service contract.&amp;nbsp;Figure 5&amp;nbsp;shows the Service Interfaces corresponding to the buyer and seller in&#xD;
    the purchasing service, a compound service.&amp;nbsp;The seller has two ports, each corresponding to the roles played in&#xD;
    the ordering service and invoicing service. Likewise, the buyer has two ports, each corresponding to the roles it plays&#xD;
    in the same services. These ports are typed by the ServiceInterfaces of the corresponding nested services. The&#xD;
    purchasing service specifies how these classes work together and defines the behavioral specification required for&#xD;
    each.&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;2&quot;>&lt;font size=&quot;2&quot;>When a compound service is used, it looks no different than any other service in a&#xD;
    services architecture.&amp;nbsp; This hides the detail of the more granular service in the high-level architecture, but it&#xD;
    still provides traceability through all levels.&lt;/font>&lt;/font>&amp;nbsp;&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:GuidanceDescription>
