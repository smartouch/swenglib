<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-AP85ZdIQODY83q5IFJmsqg" name="new_concept,_8yR7IOKwEd-G2pDngtqTxA" guid="-AP85ZdIQODY83q5IFJmsqg" changeDate="2010-10-28T09:33:45.531-0700" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    The distribution view deals with how objects find and collaborate with each other even though they may be in different&#xD;
    address spaces.&amp;nbsp; The distribution view includes policies for how the objects communicate, including the selection&#xD;
    and use of communication protocols.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In &lt;em>asymmetric distribution architectures&lt;/em>, an object is dedicated to a particular address space at design&#xD;
    time.&amp;nbsp; This makes finding that object simple during runtime because the other objects can be granted a prior&#xD;
    knowledge about how to locate and contact the object in question.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In &lt;em>symmetric distribution architectures&lt;/em>, the location of an object isn't decided until runtime.&amp;nbsp;&#xD;
    Symmetric architectures are useful for a complex system that must dynamically balance processing load over multiple&#xD;
    processors.&amp;nbsp; When objects become ready to run, the distributed OS runs the object in an optimal locale, based on&#xD;
    the current loadings on the various processors.&amp;nbsp; This improves overall performance, but at a cost--increased&#xD;
    complexity.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Selecting a distribution architecture is highly driven by the QoS of the collaboration.&amp;nbsp; The most relevant QoS to&#xD;
    drive the distribution architecture include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Performance &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Worst&amp;nbsp;case&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Average case&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Predictability&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Throughput &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Average&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Burst&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Reliability &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Of message delivery&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Of message Integrity&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Recurring (e.g., hardware) cost&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The most important QoS requirements depend on the specific system that is being built.&amp;nbsp; For example, in real-time&#xD;
    and embedded systems, performance can be crucial to success.&amp;nbsp;&amp;nbsp;In hard real-time and safety-critical systems,&#xD;
    worst-case delivery time is the most important.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You can represent the system by using class or structure diagrams.&amp;nbsp; These diagrams show structural elements and&#xD;
    their relations.&amp;nbsp; You can use sequence diagrams that show how these elements interact or&amp;nbsp;state machines that&#xD;
    depict the behavioral specifications of individual elements.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
