<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-8Pg5zglm5jxRS8lsdkRRrg" name="new_guideline,_9rjSMOLAEd-G2pDngtqTxA" guid="-8Pg5zglm5jxRS8lsdkRRrg" changeDate="2010-10-28T11:28:15.875-0700" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    Like the preceding design phases, detailed design proceeds largely through the application of design patterns (also&#xD;
    referred to as design &quot;idioms&quot;). That is, for the most part, the problems you're trying to address in this&#xD;
    most-detailed level of design have been solved before in different systems and perhaps for different applications.&#xD;
    However, those solutions can be abstracted, generalized, and reapplied in new situations, including your current system&#xD;
    under development. The issues normally addressed during detailed design include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Ensuring operation pre- and post-conditional invariants, such as &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Range checking&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Reasonableness checking&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Unit checking (e.g. miles vs. kilometers)&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Internal data structuring&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Internal algorithmic structuring and optimization&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Optimization of state machines&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Specifying local error and exception handling (both accepted and thrown)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Low-level redundancy for safety and reliability&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Numeric round off error management and correction&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Abstraction of services into interfaces&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Class feature visibility&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Ensuring quality of service budget adherence for services&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Realization of associations, e.g. &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Pointers&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                References&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Object IDs&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Widget handles&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Socket&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                â€¦&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Be sure to validate the class both in isolation and in the collaboration to ensure 1) the functionality has not&#xD;
        been broken with the changes and 2) the desired optimizations are achieved.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Data re-structuring attempts to optimize the class attributes in terms of the identified optimization criteria,&#xD;
        e.g. &quot;read time&quot; vs. &quot;write time&quot; or memory usage vs. pre-computation. One key concern is the selection of the&#xD;
        appropriate primitive representational type (e.g. int, short, long, or double), the acceptable sub range within&#xD;
        that base type and how the class will ensure the value(s) stay within the appropriate range as well as what to do&#xD;
        if they do not.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Operations hold the code for method functions of classes. While most methods are short (3-10 lines long), some may be&#xD;
    highly complex (e.g. &quot;computeKalmanFilter()&quot;) and may need to be decomposed, possibly across multiple classes or parts&#xD;
    of the main class. This might be done just to manage the complexity of the algorithm (although if the operation is&#xD;
    complex, it is recommended that the operation be represented in an activity diagram and then code can be generated for&#xD;
    it), or to optimize the operation for initiation or execution time (e.g. worst-case performance, average performance,&#xD;
    read performance, write performance, predictability of performance, minimization of jitter, etc), safety, reliability,&#xD;
    or resource usage.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
