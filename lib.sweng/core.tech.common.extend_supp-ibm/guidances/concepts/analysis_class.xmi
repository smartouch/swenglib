<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-auA2J__qpYwX7q38JNe6oQ" name="new_concept,_vKGosIBrEd2z9IawWqZSFw" guid="-auA2J__qpYwX7q38JNe6oQ" changeDate="2008-09-17T15:04:17.342-0700" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    Analysis classes specify elements of an early conceptual model for things in the system that have responsibilities and&#xD;
    behavior. They represent the prototypical classes of the system, and are a first-pass at the major abstractions that&#xD;
    the system must handle. Some architects and designers maintain analysis classes even after the system is implemented,&#xD;
    in order to communicate a high-level conceptual overview of the system. Each analysis class typically evolves into one&#xD;
    or more logical and physical components in the system architecture.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An analysis class has properties including a name, description, responsibilities, and attributes. The description&#xD;
    includes the role the class plays in the system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Analysis classes may be stereotyped as one of the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Boundary classes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Control classes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Entity classes&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    These stereotypes are useful in helping you to identify components in the component model. Apart from giving you more&#xD;
    specific process guidance when finding components, this stereotyping results in a robust component model, because&#xD;
    changes to the model tend to affect only a specific area. Changes in the user interface, for example, affect only&#xD;
    boundary classes. Changes in the control flow affect only control classes. Changes in long-term information affect only&#xD;
    entity classes.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;4&quot;>Boundary Class&lt;br />&#xD;
    &lt;/font>&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A &lt;strong>boundary class&lt;/strong> is a class used to model interaction between the system's surroundings and its inner&#xD;
    workings. Such interaction involves transforming and translating events, and noting changes in the system presentation&#xD;
    (such as the interface).&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Boundary classes model the parts of the system that depend on its surroundings. Entity classes and control classes&#xD;
    model the parts that are independent of the system's surroundings. Thus, changing the GUI or communication protocol&#xD;
    should mean changing only the boundary classes, not the entity and control classes.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A system may have several types of boundary classes:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>User interface classes&lt;/strong>: Intermediate communication with human users of the system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>System interface classes&lt;/strong>: Intermediate communication with other system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Device interface classes&lt;/strong>: Provide the interface to devices (such as sensors) that detect external&#xD;
        events&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Common boundary classes include windows, communication protocols, printer interfaces, sensors, and terminals.&#xD;
    Generally, an entire window is the finest-grained boundary object. Boundary classes are also useful for capturing&#xD;
    interfaces to APIs, such as legacy code.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Boundary classes make it easier to understand the system, because they clarify the system's boundaries. They aid&#xD;
    modeling by helping group related services. For example, if you identify a printer interface, you soon see that you&#xD;
    must also model the formatting of printouts.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;4&quot;>Control class&lt;/font>&lt;/strong>&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A &lt;strong>control class&lt;/strong> is a class used to model control behavior specific to one or a few functional&#xD;
    requirements. They often control other objects, so they implement coordinating behavior. Control classes encapsulate&#xD;
    specific functional requirements.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The behavior of a control class is closely related to a specific scenario of system use. A control object can direct&#xD;
    the system in carrying out more than one closely-related functional requirements, or several control objects can&#xD;
    coordinate a single requirement. Examples of control objects include transaction managers, resource coordinators, and&#xD;
    error handlers. Not all functional requirements require a control class.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A control class does not handle all system functionality itself. Instead, it coordinates the tasks of other objects&#xD;
    that implement the functionality. The control class delegates work to the objects that have been assigned the&#xD;
    responsibility for the functionality.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Control classes can contribute to your understanding of the system, because they represent the dynamics of the system,&#xD;
    handling the main tasks and control flows. Control classes effectively de-couple boundary and entity objects from one&#xD;
    another, making the system more tolerant of changes in the system boundary. They also de-couple the system-specific&#xD;
    behavior from the entity objects, making them more reusable across systems.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;4&quot;>Entity class&lt;/font>&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An &lt;strong>entity class&lt;/strong> is a class used to model information that must be stored, and associated behavior&#xD;
    related to managing that information. Use entity classes to hold and update information about some concept, such as an&#xD;
    event, a person, or some real-life object. They are usually persistent, having attributes and relationships needed for&#xD;
    a long period, sometimes for the life of the system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An entity object is usually used in many places throughout the system. Sometimes, it is not even specific to the system&#xD;
    itself. Users or other systems often provide the values of its attributes and relationships. An entity class may also&#xD;
    help perform internal system tasks. Entity classes can have behavior as complicated as that of other types of analysis&#xD;
    classes. However, unlike other types of classes, this behavior is strongly related to the entity it represents. Entity&#xD;
    objects are independent of the environment.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Entity classes represent the key concepts of the system. Typical examples of entity classes in a banking system are&#xD;
    Account and Customer. In a network-handling system, examples are Node and Link.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Entity classes provide another point of view from which to understand the system. They show the logical data structure,&#xD;
    which can help you understand what the system is supposed to offer its users.&lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
