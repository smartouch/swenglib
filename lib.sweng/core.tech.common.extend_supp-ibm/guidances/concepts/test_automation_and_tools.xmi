<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-kmL6u_Er3B2kOK3TjXRPvQ" name="test_automation_and_tools,_fGQhQHHSEdyzS55ez-koKA" guid="-kmL6u_Er3B2kOK3TjXRPvQ" changeDate="2007-12-27T11:47:32.250-0800" version="7.2">
  <mainDescription>&lt;p>&#xD;
    Test automation tools are increasingly being brought to the market to automate Test tasks. A number of automation tools&#xD;
    exist, but it's unlikely that a single tool is capable of automating all test tasks. Most tools focus on a specific&#xD;
    task or group of tasks, whereas some only address one aspect of a task.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When evaluating different tools for test automation, it's important to be aware of the type of tool you are evaluating,&#xD;
    the limitations of the tool, and what tasks the tool addresses and automates. Test tools are often evaluated and&#xD;
    acquired based on these categories:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Function&quot;>Function&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#White-boxBlack-box&quot;>White-box vs. Black-box&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Specialization&quot;>Specialization&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;Function&quot; name=&quot;Function&quot;>Function&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Test tools may be categorized by the functions they perform. Typical function designations for tools include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Data acquisition tools&lt;/b> that acquire data to be used in the test tasks. The data may be acquired through&#xD;
        conversion, extraction, transformation, or capture of existing data, or through generating use cases or&#xD;
        supplemental specifications.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Static measurement tools&lt;/b> that analyze information contained in the design models, source code, or other&#xD;
        fixed sources. The analysis yields information on the logic flow, data flow, or quality metrics such as complexity,&#xD;
        maintainability, or lines of code.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Dynamic measurement tools&lt;/b> that perform an analysis during the execution of the code. The measurements&#xD;
        include the run-time operation of the code such as memory, error detection, and performance.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Simulators&lt;/b> or &lt;b>drivers&lt;/b> that perform tasks, which for reasons of timing, expense, or safety are not&#xD;
        available for testing purposes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Test management tools&lt;/b> that assist in planning, designing, implementing, executing, evaluating, and managing&#xD;
        the test tasks or work products.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;White-boxBlack-box&quot; name=&quot;White-boxBlack-box&quot;>White-box vs. Black-box&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Test tools are often characterized as either white-box or black-box based upon the manner in which tools are used, or&#xD;
    the technology and knowledge needed to use the tools.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>White-box tools&lt;/b> rely upon knowledge of the code, design models, or other source material to implement and&#xD;
        execute the tests.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Black-box tools&lt;/b> rely only upon the use cases or functional description of the target-of-test.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Whereas white-box tools have knowledge of how the target-of-test processes the request, black-box tools rely upon the&#xD;
    input and output conditions to evaluate the test.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;Specialization&quot; name=&quot;Specialization&quot;>Specialization&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In addition to the broad classifications of tools previously presented, tools may also be classified by specialization.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Record and Playback tools&lt;/b> combine data acquisition with dynamic measurement. Test data is acquired during&#xD;
        the recording of events (known as test implementation). Later, during test execution, the data is used to playback&#xD;
        the test script, which is used to evaluate the execution of the target-of-test.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Quality metrics tools&lt;/b> are static measurement tools that perform a static analysis of the design models or&#xD;
        source code to establish a set of parameters that describe the target-of-test's quality. The parameters may&#xD;
        indicate reliability, complexity, maintainability, or other measures of quality.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Coverage monitoring tools&lt;/b> indicate the completeness of testing by identifying how much of the target-of-test&#xD;
        was covered, in some dimension, during testing. Typical classes of coverage include use cases (requirements-based),&#xD;
        logic branch or node (code-based), data state, and function points.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Test case generators&lt;/b> automate the generation of test data. Test case generators use either a formal&#xD;
        specification of the target-of-test's data inputs, or the design models and source code to produce test data that&#xD;
        tests the nominal inputs, error inputs, and limit and boundary cases.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Comparator tools&lt;/b> compare test results with reference results and identify differences. Comparators differ in&#xD;
        their specificity to particular data formats. For example, comparators may be pixel-based to compare bitmap images&#xD;
        or object-based to compare object properties or data.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Data extractors&lt;/b> provide inputs for test cases from existing sources, including databases, data streams in a&#xD;
        communication system, reports, or design models and source code.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
