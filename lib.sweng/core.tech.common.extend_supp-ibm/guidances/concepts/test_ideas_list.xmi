<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-6msqfcC_ZBvxJfOHEpVAYQ" name="test_ideas_list,_othWcHHSEdyzS55ez-koKA" guid="-6msqfcC_ZBvxJfOHEpVAYQ" changeDate="2008-04-28T15:22:19.156-0700" version="7.2.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Information used in designing tests is gathered from many places: design models, classifier interfaces, statecharts,&#xD;
    and code itself. At some point, this source document information must be transformed into executable tests:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        specific inputs given to the software under test&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        a particular hardware and software configuration&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        initialized to a known state&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        specific results expected&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    It's possible to go directly from source document information to executable tests, but it's often useful to add an&#xD;
    intermediate step. In this step,&lt;em>&amp;nbsp;&lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend-ibm/guidances/termdefinitions/test_idea_C3E60830.html&quot; guid=&quot;_ru5GwLSvEdyPwbrU35sd4A&quot;>test ideas&lt;/a>&lt;/em> are written into a &lt;i>Test-Ideas List&lt;/i>, which is used to create&#xD;
    executable tests.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;TestIdeas&quot; name=&quot;TestIdeas&quot;>What are Test Ideas?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A test idea (sometimes referred to as a &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.tech.common.extend-ibm/guidances/termdefinitions/test_requirement_D46BA4A3.html&quot; guid=&quot;_2k18oLSvEdyPwbrU35sd4A&quot;>test requirement&lt;/a>) is a brief statement about a test that could be performed. As a&#xD;
    simple example, let's consider a function that calculates a square root and come up with some test ideas:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        give a number that's barely less than zero as input&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        give zero as the input&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        test a number that's a perfect square, like 4 or 16 (is the result exactly 2 or 4?)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Each of these ideas could readily be converted into an executable test with exact descriptions of inputs and expected&#xD;
    results.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are two advantages to this less-specific intermediate form:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        test ideas are more reviewable and understandable than complete tests-it's easier to understand the reasoning&#xD;
        behind them&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        test ideas support more powerful tests, as described later&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The square root examples all describe inputs, but test ideas can describe any of the elements of an executable test.&#xD;
    For example, &quot;print to a LaserJet IIIp&quot; describes an aspect of the&amp;nbsp;&lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.tech.common.extend-ibm/guidances/termdefinitions/test_environment_1304DF1F.html&quot; guid=&quot;_ouDPILSzEdyPwbrU35sd4A&quot;>test environment&lt;/a> to be used for a test, as does &quot;test with database full&quot;, however,&#xD;
    these latter test ideas are very incomplete in themselves: Print &lt;b>what&lt;/b> to the printer? Do &lt;b>what&lt;/b> with that&#xD;
    full database? They do, however, ensure that important ideas aren't forgotten; ideas that will be described in more&#xD;
    detail later in test design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Test ideas are often based on &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend-ibm/guidances/termdefinitions/fault_model_32142724.html&quot; guid=&quot;_YjUF4LSzEdyPwbrU35sd4A&quot;>fault models&lt;/a>; notions of which faults are plausible in software and how those faults&#xD;
    can best be uncovered. For example, consider boundaries. It's safe to assume the square root function can be&#xD;
    implemented something like this:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
&lt;pre>&#xD;
double sqrt(double x) {&#xD;
if (x &amp;lt; 0) &#xD;
// signal error&#xD;
...&#xD;
&lt;/pre>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    It's also plausible that the &lt;b>&amp;lt;&lt;/b> will be incorrectly typed as &lt;b>&amp;lt;=&lt;/b>. People often make that kind of&#xD;
    mistake, so it's worth checking. The fault cannot be detected with &lt;b>X&lt;/b> having the value &lt;b>2&lt;/b>, because both the&#xD;
    incorrect expression (&lt;b>x&amp;lt;=0&lt;/b>) and the correct expression (&lt;b>x&amp;lt;0&lt;/b>) will take the same branch of the&#xD;
    &lt;b>if&lt;/b> statement. Similarly, giving &lt;b>X&lt;/b> the value -&lt;b>5&lt;/b> cannot find the fault. The only way to find it is&#xD;
    to give &lt;b>X&lt;/b> the value &lt;b>0&lt;/b>, which justifies the second test idea.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In this case, the fault model is explicit. In other cases, it's implicit. For example, whenever a program manipulates a&#xD;
    linked structure, it's good to test it against a circular one. It's possible that many faults could lead to a&#xD;
    mishandled circular structure. For the purposes of testing, they needn't be enumerated-it suffices to know that some&#xD;
    fault is likely enough that the test is worth running.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    These fault models can be applied to many different work products. For example, the first one describes what to do with&#xD;
    Boolean expressions. Such expressions can be found in code, in guard conditions, in statecharts and sequence diagrams,&#xD;
    and in natural-language descriptions of method behaviors (such as you might find in a published API).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Occasionally it's also helpful to have guidelines for specific work products.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A particular Test-Ideas List might contain test ideas from many fault models, and those fault models could be derived&#xD;
    from more than one work product.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;TestDesignUsingTheList&quot; name=&quot;TestDesignUsingTheList&quot;>Test Design Using the List&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Let's suppose you're designing tests for a method that searches for a string in a sequential collection. It can either&#xD;
    obey case or ignore case in its search, and it returns the index of the first match found or -1 if no match is found.&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
&lt;pre>&#xD;
int Collection.find(String string,&#xD;
Boolean ignoreCase);&#xD;
&lt;/pre>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Here are some test ideas for this method:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        match found in the first position&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        match found in the last position&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        no match found&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        two or more matches found in the collection&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        case is ignored; match found, but it wouldn't match if case was obeyed&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        case is obeyed; an exact match is found&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        case is obeyed; a string that would have matched if case were ignored is skipped&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    It would be simple to implement these seven tests, one for each test idea. However, different test ideas can be&#xD;
    combined into a single test. For example, the following test &lt;i>satisfies&lt;/i> test ideas 2, 6, and 7:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        Setup: collection initialized to [&quot;dawn&quot;, &quot;Dawn&quot;]&lt;br />&#xD;
        Invocation: collection.find(&quot;Dawn&quot;, false)&lt;br />&#xD;
        Expected result: return value is 1 (it would be 0 if &quot;dawn&quot; were not skipped)&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Making test ideas nonspecific makes them easier to combine.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It's possible to satisfy all of the test ideas in three tests. Why would three tests that satisfy seven test ideas be&#xD;
    better than seven separate tests?&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        When you're creating a large number of simple tests, it's common to create test N+1 by copying test N and tweaking&#xD;
        it just enough to satisfy the new test idea. The result, especially in more complex software, is that test N+1&#xD;
        probably exercises the program in almost the same way as test N. It takes almost exactly the same path through the&#xD;
        code.&lt;br />&#xD;
        &lt;br />&#xD;
        A smaller number of tests, each satisfying several test ideas, doesn't allow a &quot;copy and tweak&quot; approach. Each test&#xD;
        will be somewhat different from the last, exercising the code in different ways and taking different paths.&lt;br />&#xD;
        &lt;br />&#xD;
        Why would that be better? If the Test-Ideas List were complete, with a test idea for every fault in the program, it&#xD;
        wouldn't matter how you wrote the tests. But the list is always missing some test ideas that could find bugs. By&#xD;
        having each test do very different things from the last one-by adding seemingly unneeded variety-you increase the&#xD;
        chance that one of the tests will stumble over a bug by sheer dumb luck. In effect, smaller, more complex tests&#xD;
        increase the chance the test will satisfy a test idea that you didn't know you needed.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Sometimes when you're creating more complex tests, new test ideas come to mind. That happens less often with simple&#xD;
        tests, because so much of what you're doing is exactly like the last test, which dulls your mind.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    However, there are reasons for not creating complex tests.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If each test satisfies a single test idea and the test for idea 2 fails, you immediately know the most likely&#xD;
        cause: the program doesn't handle a match in the last position. If a test satisfies ideas 2, 6, and 7, then&#xD;
        isolating the failure is harder.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Complex tests are more difficult to understand and maintain. The intent of the test is less obvious.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Complex tests are more difficult to create. Constructing a test that satisfies five test ideas often takes more&#xD;
        time than constructing five tests that each satisfy one. Moreover, it's easier to make mistakes-to think you're&#xD;
        satisfying all five when you're only satisfying four.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In practice, you must find a reasonable balance between complexity and simplicity. For example, the first tests you&#xD;
    subject the software to (typically the &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend-ibm/guidances/termdefinitions/smoke_test_35E20F16.html&quot; guid=&quot;_Jk5wYLS0EdyPwbrU35sd4A&quot;>smoke tests&lt;/a>) should be simple, easy to understand and maintain, and intended to&#xD;
    catch the most obvious problems. Later tests should be more complex, but not so complex they are not maintainable.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    After you've finished a set of tests, it's good to check them against the characteristic test design mistakes.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;UsingTestIdeasBeforeTest&quot; name=&quot;UsingTestIdeasBeforeTest&quot;>Using Test Ideas Before Testing&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A Test-Ideas List is useful for reviews and inspections of design work products. For example, consider this part of&#xD;
    a&amp;nbsp;design model&amp;nbsp;showing the association between Department and Employee classes.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;45&quot; alt=&quot;Design Model Example Image&quot; src=&quot;./resources/tstidslst-img1.gif&quot; width=&quot;223&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Figure 1: Association between Department and Employee Classes&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The rules for creating test ideas from such a model would ask you to consider the case where a department has many&#xD;
    employees. By walking through a design and asking &quot;what if, at this point, the department has many employees?&quot;, you&#xD;
    might discover design or analysis errors. For example, you might realize that only one employee at a time can be&#xD;
    transferred between departments. That might be a problem if the corporation is prone to sweeping reorganizations where&#xD;
    many employees need to be transferred.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Such faults, cases where a possibility was overlooked, are called &lt;i>faults of omission&lt;/i>. Just like the faults&#xD;
    themselves, you have probably omitted tests that detect these faults from your testing effort. For example, see&#xD;
    [GLA81], [OST84], [BAS87], [MAR00], and other studies that show how often faults of omission escape into&#xD;
    deployment.&amp;nbsp;&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;TestIdeasTraceability&quot; name=&quot;TestIdeasTraceability&quot;>Test Ideas and Traceability&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Traceability&amp;nbsp;is a matter of tradeoffs. Is its value worth the cost of maintaining it?&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When traceability is worthwhile, it's conventional to trace tests back to the work products that inspired them. For&#xD;
    example, you might have traceability between an API and its tests. If the API changes, you know which tests to change.&#xD;
    If the code (that implements the API) changes, you know which tests to run. If a test puzzles you, you can find the API&#xD;
    it's intended to test.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Test-Ideas List adds another level of traceability. You can trace from a test to the test ideas it satisfies, and&#xD;
    then from the test ideas to the original work product.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    References&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        GLA81&amp;nbsp;&amp;nbsp; Robert L. Glass 1981. &lt;i>Persistent Software Errors.&lt;/i> IEEE Transactions on Software&#xD;
        Engineering, March 1981.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        OST84&amp;nbsp;&amp;nbsp;&amp;nbsp;Thomas J. Ostrand and Elaine J. Weyuker 1984. &lt;i>Collecting and Categorizing Software Error&#xD;
        Data in an Industrial Environment.&lt;/i> Journal of Systems and Software, Vol. 4, 1984.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        BAS87&amp;nbsp;&amp;nbsp; BAS87 Victor R. Basili and H. Dieter Rombach 1987. &lt;i>Tailoring the Software Process to Project&#xD;
        Goals and Environments.&lt;/i> Proceedings of the 9th International Conference on Software Engineering Software, IEEE&#xD;
        Press.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        MAR00&amp;nbsp;&amp;nbsp; Brian Marick 2000. &lt;i>Faults of Omission.&lt;/i> Software Testing and Quality Engineering Magazine,&#xD;
        March-April 2000.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
