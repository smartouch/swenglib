<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-kY8JvMVldxRAFnidaxU4Dw" name=",_Z0flMHg_EdyONKO6Ef77qQ" guid="-kY8JvMVldxRAFnidaxU4Dw" changeDate="2010-05-17T10:25:28.004-0700" version="7.2">
  <mainDescription>&lt;p>&#xD;
    Testing is applied to different types of targets, in different stages or levels of work effort. These levels are&#xD;
    distinguished typically by those roles that are best skilled to design and conduct the tests, and where techniques are&#xD;
    most appropriate for testing at each level. It's important to ensure a balance of focus is retained across these&#xD;
    different work efforts.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Developer Testing&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Developer testing denotes the aspects of test design and implementation most appropriate for the team of developers to&#xD;
    undertake; this is in contrast to independent testing.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Traditionally, developer testing has been considered mainly with respect to unit testing. While some developers also&#xD;
    perform varying levels integration testing, this is largely dependent on culture and other context issues.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Independent Testing&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Independent testing denotes the test design and implementation most appropriately performed by someone who is&#xD;
    independent from the team of developers. You can consider this distinction a superset, which includes Independent&#xD;
    Verification &amp;amp; Validation. In most cases, test execution initially occurs with the independent testing group that&#xD;
    designed and implemented the test, but the independent testers should create their tests to make them available to the&#xD;
    developer testing groups for execution. Boris Beizer gives the following explanation of the different objective that&#xD;
    independent testing has over developer testing:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        &quot;The purpose of independent testing is to provide a different perspective and, therefore, different tests;&#xD;
        furthermore to conduct those tests in a richer [...] environment than is possible for the developer.&quot; [Boris Beizer&#xD;
        1995. &lt;i>Black Box Testing.&lt;/i> New York, NY: John Wiley &amp;amp; Sons, Inc]&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;h4>&#xD;
    Independent Stakeholder Testing&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An alternate view of independent testing is that it represents testing that is based on the needs and concerns of&#xD;
    various stakeholders. Therefore it's referred to as Stakeholder Testing. This is an important distinction-it helps to&#xD;
    include a broader set of stakeholder concerns than might traditionally be considered, extending the somewhat generic&#xD;
    &quot;customer&quot; with stakeholders such as technical support staff, technical trainers, sales staff in additional to&#xD;
    customers, and users.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As a final comment, &lt;em>Extreme Programming&lt;/em>'s notion of &lt;i>customer tests&lt;/i> relates to this categorization of&#xD;
    independent testing.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Unit Testing&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Unit testing focuses on verifying the smallest testable elements of the software. Typically unit testing is applied to&#xD;
    components represented in the implementation model to verify that control flows and data flows are covered, and that&#xD;
    they function as expected. The&amp;nbsp;developers perform unit testing as the unit is developed.&#xD;
&lt;/p>&#xD;
&lt;!-- &lt;p>These expectations are based on how the component participates in executing    a use case, which you find in sequence diagrams for that use case.&lt;/p> -->&#xD;
&lt;h3>&#xD;
    Integration Testing&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Integration testing is performed to ensure that the components in the implementation model operate properly when&#xD;
    combined. The target-of-test is a package or a set of packages in the implementation model. Often the packages being&#xD;
    combined come from different development organizations. Integration testing exposes incompleteness or mistakes in the&#xD;
    package's interface specifications.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In some cases, the assumption by developers is that other groups such as independent testers will perform integration&#xD;
    tests. This situation presents risks to the software project and ultimately the software quality because:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        integration areas are a common point of software failure.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        integration tests performed by independent testers typically use black-box techniques and are typically dealing&#xD;
        with larger software components.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A better approach is to consider integration testing the responsibility of both developer and independent testers, but&#xD;
    make sure that the strategies of each team testing efforts do not overlap significantly. The exact nature of that&#xD;
    overlap is based on the needs of the individual project. We recommend you foster an environment where developers and&#xD;
    independent system testers share a single vision of quality. See&amp;nbsp;&lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.tech.common.extend_supp/guidances/concepts/developer_testing_FEBDAED6.html&quot; guid=&quot;_ADwlAJRtEdyrdaw_xGakyw&quot;>Developer Testing&lt;/a>&amp;nbsp;for additional information.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    System Testing&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Traditionally system testing is done when the software is functioning as a whole. An iterative lifecycle allows system&#xD;
    testing to occur much earlier-as soon as well-formed subsets of the use-case behavior are implemented. Usually the&#xD;
    target is the system's end-to-end functioning elements.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Acceptance Testing&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;i>User&lt;/i> acceptance testing is the final test action taken before deploying the software. The goal of acceptance&#xD;
    testing is to verify that the software is ready, and that it can be used by users to perform those functions and tasks&#xD;
    for which the software was built. See&amp;nbsp;&lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.tech.common.extend_supp-ibm/guidances/concepts/acceptance_testing_EA8FA3B0.html&quot; guid=&quot;_vYGlsHhBEdyONKO6Ef77qQ&quot;>Acceptance Testing&lt;/a> for additional information.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are other notions of acceptance testing, which are generally characterized by a hand-off from one group or one&#xD;
    team to another. For example, a &lt;i>build acceptance test&lt;/i> is the testing done to accept the hand-over of a new&#xD;
    software build from development into independent testing.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    A comment about sequence and timing of test levels&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Traditionally, unit testing is thought of as being implemented early, as the first stage of testing: all units required&#xD;
    to be passed before subsequent stages are conducted. However, in an iterative development process, this approach is as&#xD;
    a general rule, inappropriate. A better approach is to identify the unit, integration and system tests that offer most&#xD;
    potential for finding errors, then implement and execute them based on a combination of greatest risk and supporting&#xD;
    environment.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
