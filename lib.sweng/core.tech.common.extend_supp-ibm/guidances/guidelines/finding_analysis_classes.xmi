<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-tCqwFkkJJvpz_pmNQVDUEw" name="new_concept,_QanxsIBtEd2z9IawWqZSFw" guid="-tCqwFkkJJvpz_pmNQVDUEw" changeDate="2008-09-17T15:06:10.004-0700" version="7.5.0">
  <mainDescription>By finding &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend_supp-ibm/guidances/concepts/analysis_class_DA9AF873.html&quot; guid=&quot;_vKGosIBrEd2z9IawWqZSFw&quot;>Analysis Classes&lt;/a>, you outline the key elements in a system. These elements evolve&#xD;
quickly, and remain fluid as you explore different ways to incorporate them into your architecture. Formal documentation&#xD;
can impede this process, so be careful how much energy you expend on maintaining this model in a formal sense; you can&#xD;
waste a lot of time polishing a model that is largely expendable. Analysis classes rarely survive in the architecture&#xD;
unchanged. Many of them represent whole collaborations of objects, often encapsulated by subsystems.&lt;br />&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;3&quot;>&lt;font size=&quot;4&quot;>Finding boundary classes&lt;/font>&lt;br />&#xD;
    &lt;/font>&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A boundary class remediates the interface to something outside the system. Boundary classes insulate the system from&#xD;
    changes in the surroundings (changes in interfaces to other systems, changes in user requirements, and so on), keeping&#xD;
    these changes from affecting the rest of the system. Typical types of boundary classes include user interface, system&#xD;
    interface, and device interface elements.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Model boundary classes according to what kind of boundary they represent. Communication with another system and&#xD;
    communication with a user (through a user interface) have very different objectives. For communication with a user, the&#xD;
    most important concern is how the system presents the interface to the user. For communication with another system, the&#xD;
    most important concern is the communication protocol.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Find user interface classes&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Define one boundary class for each &quot;conversation&quot; between the system and a user. This class has the responsibility for&#xD;
    coordinating the interaction with the user. You may also define subsidiary boundary classes, to which the primary&#xD;
    boundary class delegates some of its responsibilities. This is particularly true for window-based GUI applications,&#xD;
    where you may model one boundary class for each window or form. Only model the key abstractions of the system; do not&#xD;
    model every button, list, and widget in the GUI. The goal of using analysis classes is to form a good picture of how&#xD;
    the system is composed, not to capture every last detail.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Find system interface classes&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A boundary class that communicates with an external system is responsible for managing the exchange of information with&#xD;
    the external system: it provides the interface to that system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For example, in an Automated Teller Machine, withdrawal of funds must be verified through the ATM Network, a system&#xD;
    that verifies the withdrawal with the bank accounting system. A class called ATM Network Interface captures all of the&#xD;
    behavior related to communication with the ATM Network.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The interface to an existing system may already be well-defined. If so, derive the responsibilities directly from the&#xD;
    interface definition. If a formal interface definition exists, you do not need to formally define it here. Simply make&#xD;
    note that the existing interface will be reused.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Find device interface classes&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The system may contain external devices (such as sensor equipment) that change value spontaneously without any object&#xD;
    in the system affecting them. You need to consider the source for all external events, and make sure that you have a&#xD;
    way for the system to detect these events.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For each device, create a boundary class to capture its responsibilities. If there is a well-defined interface already&#xD;
    existing for the device, make note of it for later reference.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;4&quot;>Finding control classes&lt;/font>&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Control classes provide coordinating behavior in the system. Complex requirements generally require one or more control&#xD;
    classes to coordinate the behavior of other objects in the system. Requirements that involve only the simple&#xD;
    manipulation of stored information may not require control objects: they can just use entity and boundary&#xD;
    objects.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Use control classes to model behavior that:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Is independent of surroundings;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Defines control logic (order between events);&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Changes little if the internal structure or behavior of entity classes change;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Uses or sets the contents of several entity classes, and therefore needs to coordinate their behavior;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Is not performed in the same way every time that it is activated.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Start by identifying one control class for each scenario of system use.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Determine whether you need a control class&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For each flow of system events, start by investigating if the flow can be handled by the already identified boundary&#xD;
    and entity classes. For simple flows of events that primarily enter, retrieve and display, or modify information, a&#xD;
    separate control class is not usually justified; the boundary classes should be responsible for coordinating&#xD;
    behavior.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Use a separate control class when behavior is complex and dynamic, and may change independently from the interfaces&#xD;
    (boundary classes) or information stores (entity classes). By encapsulating a particular flow of events, you can&#xD;
    potentially reuse the same control class for a variety of systems that may have different interfaces and different&#xD;
    information stores.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Divide complex classes along lines of similar responsibilities&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Consider a requirement to manage a queue of tasks. You may identify a control class to handle the queue of tasks,&#xD;
    ensuring that tasks execute in the right order. It performs the next task in the queue as soon as suitable resources&#xD;
    are available. The system can therefore perform several tasks at the same time.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This control object is easier to describe if you split it into two control classes:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A &lt;strong>Queue Handler&lt;/strong> object handles only the queue order and the allocation of transportation&#xD;
        equipment. One Queue Handler object manages the whole queue. As soon as the system needs to perform a task, it&#xD;
        creates a new Task Performer object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A &lt;strong>Task Performer&lt;/strong> object performs tasks. One Task Performer object handles each task the system&#xD;
        performs.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The principal benefit of this split is to separate queue handling responsibilities (something generic to many&#xD;
    circumstances) from the specific tasks of task management, which are specific to this scenario. This makes the classes&#xD;
    easier to understand, and easier to adapt as the system matures.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Separate the main flow of events from alternative or exceptional flows of events&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To simplify changes, encapsulate the main flow of events and alternative flows of events in different control classes.&#xD;
    If alternative and exception flows are completely independent, separate them from each other as well. This makes the&#xD;
    system easier to extend and maintain over time.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Divide control classes where two actors share the same control class&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Control classes may also need to be divided when several actors (elements outside the system that interact with the&#xD;
    system) use the same control class. By doing this, you isolate changes in the requirements of one actor from the rest&#xD;
    of the system. In cases where the cost of change is high, identify all of the control classes related to more than one&#xD;
    actor and divide them. In the ideal case, each control class should interact (via some boundary object) with one actor&#xD;
    or none at all.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You do not have to divide a control class if:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        You can be reasonably sure that the behavior of the actors related to the control class will never change, or&#xD;
        change very little.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The behavior of the control class toward one actor is very insignificant compared with its behavior toward another&#xD;
        actor. In this case, a single class can hold all of the behavior. Combining behavior in this way will have a&#xD;
        negligible effect on maintainability.&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    For example, consider the requirement to handle local phone calls in a telephone system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In a local phone call, there are two actors:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>A-subscriber&lt;/strong> initiates the call. This subscriber lifts the receiver, hears the dial tone, and then&#xD;
        dials a number of digits, which the system stores and analyzes. When the system has received all of the digits, it&#xD;
        sends a ringing tone to A-subscriber, and a ringing signal to B-subscriber.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>B-subscriber&lt;/strong> receives the call. When B-subscriber hears the ringing tone and answers the call, the&#xD;
        tone and the signal stop, and the conversation between the subscribers can begin.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The call ends when both subscribers hang up.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Initially, you may identify a control class to manage the call itself. However, two behaviors must be controlled: what&#xD;
    happens on A-subscriber's end and what happens on B-subscriber's end. For this reason, split the original control&#xD;
    object into two control objects, A-behavior and B-behavior.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;4&quot;>Finding entity classes&lt;/font>&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Entity classes represent stores of information in the system. They are typically used to represent the key concepts&#xD;
    that the system manages. Entity objects are frequently passive and persistent. Their main responsibilities are to store&#xD;
    and manage information in the system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If your requirements have a glossary or a business-domain model, use this as a source of inspiration for entity&#xD;
    classes.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the concept you wish to model is not used by any other class, you can model it as an attribute of an entity class,&#xD;
    or even as a relationship between entity classes. If any other class uses it, model it as a class.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Enforcing consistency&lt;br />&#xD;
    &lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When you identify a new behavior, check to see if an existing class has similar responsibilities, reusing classes where&#xD;
    possible. Only create new classes when you are sure that no existing object can perform the behavior.&lt;br />&#xD;
    &lt;br />&#xD;
    As you identify classes, examine them to ensure that they have consistent responsibilities. When class responsibilities&#xD;
    are disjoint, split the object into two or more classes.&lt;br />&#xD;
    &lt;br />&#xD;
    A class with only one responsibility is not a problem, but it should raise questions about why you need it. Challenge&#xD;
    and justify the existence of all classes.&lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
