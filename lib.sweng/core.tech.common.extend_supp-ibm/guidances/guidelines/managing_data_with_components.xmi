<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-clgAC4MPnfbWmzmNQJwCTg" name="managing_data_with_components,_IFoswDfTEdy5uPLchEwddA" guid="-clgAC4MPnfbWmzmNQJwCTg" changeDate="2009-02-18T15:26:34.125-0800" version=".1">
  <mainDescription>&lt;p>&#xD;
    Typical project teams perform component modeling and data modeling as separate tasks. This may lead to a mismatch&#xD;
    between the dynamic or &quot;in-flight&quot; data that components require (state) and the underlying data stores that make that&#xD;
    data persistent. This technique shows a way of tying together these two separate concerns.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    One of the key elements of object-oriented design is that of encapsulation, or information hiding, whereby an object&#xD;
    binds its state and its behavior together and hides them from clients that use that object. Encapsulation is the&#xD;
    process of hiding all of the details of an object that do not contain its essential characteristics. [BOOCH91]&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.tech.common.extend_supp/guidances/concepts/component_CB167D48.html&quot; guid=&quot;_0YP18MlgEdmt3adZL5Dmdw&quot;>Components&lt;/a>, and increasingly services, adopt the same principle of encapsulation. A&#xD;
    component is a modular unit of functionality, accessed through one or more interfaces that encapsulate its own state&#xD;
    and behavior. [ADS02]&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In practice, two issues often arise when defining encapsulated components:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The logical data model is separate from the components or services that need to access data&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Components require their state to be defined and persisted in a data store&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The challenge is how to join components with the underlying databases where persistent data and state is stored.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The technique described here offers an approach for addressing this challenge, based on the work of Cheesman and&#xD;
    Daniels [CHEESMAN00]. This approach may also be appropriate for services [DODD05].&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;3&quot;>Step 1: Produce a logical data model showing business entities&lt;br />&#xD;
    &lt;/font>&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Produce a logical data model (LDM) showing business entities and the relationship between the entities in your system.&#xD;
    Figure 2 shows an example of a partial LDM for a banking application.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In this particular example, the LDM is drawn using components from UML2 with the stereotype &amp;lt;&amp;lt;entity&amp;gt;&amp;gt;.&#xD;
    Entity components model data only and do not have any associated behavior.&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;338&quot; alt=&quot;Logical Data Model&quot; src=&quot;./resources/logical_data_model.gif&quot; width=&quot;338&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2: Logical Data Model&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;3&quot;>&lt;strong>Step 2: Identify core business entities&lt;/strong>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Identify core entities to determine which data depends on other data and which is stand-alone. [CHEESMAN00]&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A core business entity is an one that:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Has an independent existence.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Has no mandatory associations to other business types.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Is within the scope of the problem space being looked at.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In the example shown in Figure 3 'Account' and 'Customer' are core because they could exist independently whereas&#xD;
    'TransactionRecord' and 'SecurityProfile' are not stand alone, they depend on 'Account' and 'Customer' respectively.&#xD;
    'Bank' could be a core business type, but it is not within the scope of problem space of this solution.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;356&quot; alt=&quot;Core Business Entities&quot; src=&quot;./resources/core_business_entities.gif&quot; width=&quot;350&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 3: Core Business Entities&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
    &lt;font size=&quot;3&quot;>&lt;strong>Step 3: Assign interfaces to manage core business entities&lt;/strong>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As a rule, create one business interface for each core entity type. Use a naming convention of the form 'IMgt', for&#xD;
    example&amp;nbsp;'IAccountMgt', indicating the interface manages instances of this type.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An Interface Responsibility Diagram is a UML2 component diagram that shows the information managed by each interface&#xD;
    and dependencies between interfaces and entities. Each entity should be owned by exactly one interface. Show allocation&#xD;
    of entities to interfaces using a UML2 association. Figure 4 shows an example Interface Responsibility Diagram. In this&#xD;
    example, you assign interfaces to the core types 'Account' and 'Customer'.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;338&quot; alt=&quot;Interface Responsibility Diagram&quot; src=&quot;./resources/interface_responsibility_diagram.gif&quot;     width=&quot;600&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 4: Interface Responsibility Diagram&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>&lt;font size=&quot;3&quot;>Step 4: Specify the information to be managed by an interface&lt;br />&#xD;
    &lt;/font>&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Interface Responsibility Diagram (Figure 4 above) shows an association between interfaces and entities from the&#xD;
    LDM. It does not show information or state that the components manage through the interfaces; an Interface&#xD;
    Specification Diagram shows this information.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Interface Specification Diagram shows the possible states of a component to which the operations can refer. All&#xD;
    changes to the state of a component caused by a given operation can be described in this information model. Showing&#xD;
    states in this way also allows you to specify pre- and post-conditions, which may affect that state.&lt;br />&#xD;
    The Interface Responsibility Diagram of Figure 4 is shown again in Figure 5 with a circle drawn around the interface&#xD;
    and associated core type.&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;img height=&quot;346&quot; alt=&quot;Interface Responsibility Diagram - Account Management&quot;     src=&quot;./resources/interface_responsibility_diagram_2.gif&quot; width=&quot;600&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;strong>Figure 5: Interface Responsibility Diagram&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot; />&#xD;
    Assign the following operations to the interface 'IAccountMgt':&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        debitAccount - debits an account by an amount&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        creditAccount - credits an account by an amount&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        getBalance - gets an account's balance&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        fundTransferAllowed - checks the possibility to transfer funds between two accounts&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        getAccountsFor - gets all the accounts for a customer&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        getAccountInformation - gets the account information&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    For each operation in the interface, specify the data it needs to pass and return. Assign the typed parameters and&#xD;
    returns to the operation. Capture this information on an Interface Specification Diagram, illustrated for the&#xD;
    IAccountMgt interface in Figure 6.&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;img height=&quot;226&quot; alt=&quot;Interface Specification Diagram&quot; src=&quot;./resources/interface_specification_diagram.gif&quot;     width=&quot;600&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;strong>Figure 6: Interface Specification Diagram&lt;/strong>&#xD;
&lt;/p>&lt;br class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot; />&#xD;
&lt;br />&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    Unlike an Interface Responsibility Diagram that shows a mapping between components, interfaces and persistent entities,&#xD;
    an Interface Specification Diagram shows a mapping between components, interfaces and the state those components have&#xD;
    at runtime.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    Represent this state using the stereotype &amp;lt;&amp;lt;informationType&amp;gt;&amp;gt;. Information types correspond to dynamic or&#xD;
    &quot;in-flight&quot; data. They are not the same as persistent data, even though they usually map to that data. Generally, an&#xD;
    entity maps to a relational database table or some other persistence mechanism, whereas an informationType is a view of&#xD;
    an underlying persistent entity. There may be several such &quot;views,&quot; each managed by different components.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    Convert the Interface Responsibility Diagram of Figure 5 to the Interface Specification Diagram of Figure 6 by removing&#xD;
    any attributes not required. The end result is that each operation in the interface contains only data types of the&#xD;
    information types managed through that interface.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    In Figure 6 the operation 'getBalance' has a parameter 'accountNum' of type 'String' and a return type of 'String'. The&#xD;
    parameters 'accountNumber' and 'currentBalance' store the information in 'Account'.&lt;br />&#xD;
    &lt;br />&#xD;
    &lt;strong>&lt;font size=&quot;3&quot;>Step 5: Assign pre- and post-conditions to the operations&lt;br />&#xD;
    &lt;/font>&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    Pre- and post-conditions are kinds of an assertion. They are false only if an error has occurred. You should usually&#xD;
    check assertions only during build (either automatically during compilation or manually during test), not during&#xD;
    runtime execution.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    Having a pre-condition makes it explicit what the caller is responsible for checking. Without this explicit statement&#xD;
    of responsibility, there could be too little or too much checking. Too much checking is as bad as too little because it&#xD;
    leads to &quot;program bloat&quot; and makes programs overly complex and difficult to maintain.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    A pre-condition does not stop an operation from executing [MEYER97]. Some practitioners erroneously use the term&#xD;
    pre-condition to describe a situation that needs to be true in order for an operation to be executed. This is better&#xD;
    termed a guard condition or the triggering event for execution. [DODD05].&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    At run time, treat pre- and post-conditions as written specifications for how the system should behave. You can then&#xD;
    test them during the various phases of testing. However, you can also check assertions at run time using some form of&#xD;
    exception handling.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    Figure 7 shows an example of a pre- and post-condition written using English for an operation in the 'IAccountMgt'&#xD;
    interface. You may write pre- and post-conditions more formally using the Object Constraint Language (OCL)&#xD;
    [WARMER99].&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;img height=&quot;352&quot; alt=&quot;Pre- and Post- Conditions&quot; src=&quot;./resources/pre_and_post_conditions.gif&quot; width=&quot;600&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;strong>Figure 7: Pre- and Post- Conditions&lt;/strong>&#xD;
&lt;/p>&lt;br class=&quot;MsoNormal&quot; style=&quot;MARGIN: 0in 0in 0pt&quot; />&#xD;
&lt;br />&#xD;
&lt;p class=&quot;MsoNormal&quot; style=&quot;MARGIN: 0in 0in 0pt&quot;>&#xD;
    See &lt;em>Patterns of Enterprise Application Architecture&lt;/em>, by Martin Fowler&lt;font face=&quot;Helv&quot;>&lt;font face=&quot;Arial&quot;>,&#xD;
    for more information about mapping between objects and relational databases.&lt;/font>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
&lt;/p>&#xD;
&lt;h4 style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    References&#xD;
&lt;/h4>&#xD;
&lt;h4 style=&quot;MARGIN: 6pt 0in&quot;>&#xD;
    &lt;br />&#xD;
&lt;/h4>&#xD;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;>&#xD;
    &lt;tbody>&#xD;
        &lt;tr>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;121&quot;>&#xD;
                &lt;p>&#xD;
                    [ADS02]&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;518&quot;>&#xD;
                &lt;p>&#xD;
                    Kahan, Ed et al. &lt;em>Architecture Description Standard Overview&lt;/em> , IBM, 2002.&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;121&quot;>&#xD;
                &lt;p>&#xD;
                    [BOOCH91]&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;518&quot;>&#xD;
                &lt;p>&#xD;
                    Booch, Grady. &lt;em>Object-Oriented Design with Applications&lt;/em> , Benjamin Cummings, 1991, ISBN:&#xD;
                    0-8053-0091-0.&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;121&quot;>&#xD;
                &lt;p>&#xD;
                    [CHEESMAN00]&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;518&quot;>&#xD;
                &lt;p>&#xD;
                    Cheesman, John &amp;amp; Daniels, John. &lt;em>UML Components&lt;/em> , Addison-Wesley, 2000, ISBN: 0201708510.&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;121&quot;>&#xD;
                &lt;p>&#xD;
                    [DODD05]&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;518&quot;>&#xD;
                &lt;p>&#xD;
                    Dodd, John. Practical Service Specification and Design Part 3: Specifying Services, CBDi Journal, June&#xD;
                    2005.&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;121&quot;>&#xD;
                &lt;p>&#xD;
                    [MEYER97]&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;518&quot;>&#xD;
                &lt;p>&#xD;
                    Meyer, Bertrand. &lt;em>Object-Oriented Software Construction&lt;/em> , Prentice-Hall, 1997, ISBN:&#xD;
                    0136291554.&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;121&quot;>&#xD;
                &lt;p>&#xD;
                    [WARMER99]&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
            &lt;td valign=&quot;top&quot; width=&quot;518&quot;>&#xD;
                &lt;p>&#xD;
                    Warmer, J and Klepp, A. &lt;em>The Object Constraint Language - Precise Modeling with UML&lt;/em> , Addison&#xD;
                    Wesley, 1999, ISBN: 0201379406.&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/tbody>&#xD;
&lt;/table></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
