<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-5HqWleqrfKN8uUKJi_TfyQ" name="maint_automated_test_suite,_IdB_sHHUEdyzS55ez-koKA" guid="-5HqWleqrfKN8uUKJi_TfyQ" changeDate="2007-12-27T11:57:37.406-0800" version="7.2">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Like physical objects, tests can break. It's not that they wear down, it's that something's changed in their&#xD;
    environment. Perhaps they've been ported to a new operating system. Or-more likely-the code they exercise has changed&#xD;
    in a way that &lt;i>correctly&lt;/i> causes the test to fail. Suppose you're working on version 2.0 of an e-banking&#xD;
    application. In version 1.0, this method was used to log in:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p align=&quot;left&quot;>&#xD;
        &lt;font size=&quot;+0&quot;>public boolean login (String username);&lt;/font>&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    In version 2.0, the marketing department has realized that password protection might be a good idea. So the method is&#xD;
    changed to this:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p align=&quot;left&quot;>&#xD;
        &lt;font size=&quot;+0&quot;>public boolean login (String username&lt;i>&lt;b>, String password&lt;/b>&lt;/i>);&lt;/font>&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Any test that uses login will fail It won't even compile. Since not much useful work is possible at this point, not&#xD;
    many useful tests can be written without login. You might be faced with hundreds or thousands of failing tests.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    These tests can be fixed by using a global search-and-replace tool that finds every instance of login(&lt;i>something&lt;/i>)&#xD;
    and replaces it with login(&lt;i>something&lt;/i>, &quot;dummy password&quot;). Then arrange for all the testing accounts to use that&#xD;
    password, and you're on your way.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Then, when marketing decides that passwords should not be allowed to contain spaces, you get to do it all over again.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This kind of thing is a wasteful burden, especially when-as is often the case-the test changes aren't so easily made.&#xD;
    There is a better way.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Suppose that the tests originally did not call the product's &lt;font size=&quot;+0&quot;>login&lt;/font> method. Rather, they called a&#xD;
    library method that does whatever it takes to get the test logged in and ready to proceed. Initially, that method might&#xD;
    look like this:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
&lt;pre>&#xD;
public boolean testLogin (String username) {&#xD;
return product.login(username);&#xD;
}&#xD;
&lt;/pre>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    When the version 2.0 change happens, the utility library is changed to match:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
&lt;pre>&#xD;
public Boolean testLogin (String username) {&#xD;
return  product.login(username&lt;b>&#xD;
&lt;i>&#xD;
, &quot;dummy password&quot;&lt;/i>&lt;/b>);&#xD;
}&#xD;
&lt;/pre>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Instead of a changing a thousand tests, you change one method.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Ideally , all the needed library methods would be available at the beginning of the testing effort. In practice, they&#xD;
    can't all be anticipated-you might not realize you need a &lt;font size=&quot;+0&quot;>testLogin&lt;/font> utility method until the&#xD;
    first time the product &lt;font size=&quot;+0&quot;>login&lt;/font> changes. So test utility methods are often &quot;factored out&quot; of&#xD;
    existing tests as needed. It is &lt;i>very&lt;/i> important that you perform this ongoing test repair, even under schedule&#xD;
    pressure. If you do not, you will waste much time dealing with an ugly and un-maintainable test suite. You might well&#xD;
    find yourself throwing it away, or being unable to write the needed numbers of new tests because all your available&#xD;
    testing time is spent maintaining old ones.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Note&lt;/b>: the tests of the product's &lt;font size=&quot;+0&quot;>login&lt;/font> method will still call it directly. If its&#xD;
    behavior changes, some or all of those tests will need to be updated. (If none of the &lt;font size=&quot;+0&quot;>login&lt;/font>&#xD;
    tests fail when its behavior changes, they're probably not very good at detecting defects.)&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;AbstractionManagesComplexity&quot; name=&quot;AbstractionManagesComplexity&quot;>Abstraction helps manage complexity&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The previous example showed how tests can abstract away from the concrete application. Most likely you can do&#xD;
    considerably more abstraction. You might find that a number of tests begin with a common sequence of method calls: they&#xD;
    log in, set up some state, and navigate to the part of the application you're testing. Only then does each test do&#xD;
    something different. All this setup could-and should-be contained in a single method with an evocative name such as&#xD;
    &lt;font size=&quot;+0&quot;>readyAccountForWireTransfer&lt;/font>. By doing that, you're saving considerable time when new tests of a&#xD;
    particular type are written, and you're also making the intent of each test much more understandable.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Understandable tests are important. A common problem with old test suites is that no one knows what the tests are doing&#xD;
    or why. When they break, the tendency is to fix them in the simplest possible way. That often results in tests that are&#xD;
    weaker at finding defects. They no longer test what they were originally intended to test.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;AnotherExample&quot; name=&quot;AnotherExample&quot;>Another example&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Suppose you're testing a compiler. Some of the first classes written define the compiler's internal parse tree and the&#xD;
    transformations made upon it. You have a number of tests that construct parse trees and test the transformations. One&#xD;
    such test might look like this:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
&lt;pre>&#xD;
/* &#xD;
* Given&#xD;
*   while (i&amp;lt;0) { f(a+i); i++;}&#xD;
* &quot;a+i&quot; cannot be hoisted from the loop because &#xD;
* it contains a variable changed in the loop.&#xD;
*/&#xD;
loopTest = new LessOp(new Token(&quot;i&quot;), new Token(&quot;0&quot;));&#xD;
aPlusI = new PlusOp(new Token(&quot;a&quot;), new Token(&quot;i&quot;));&#xD;
statement1 = new Statement(new Funcall(new Token(&quot;f&quot;), aPlusI));&#xD;
statement2 = new Statement(new PostIncr(new Token(&quot;i&quot;));&#xD;
loop = new While(loopTest, new Block(statement1, statement2));&#xD;
expect(false, loop.canHoist(aPlusI))&#xD;
&lt;/pre>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    This is a difficult test to read. Suppose that time passes. Something changes that requires you to update the tests. At&#xD;
    this point, you have more product infrastructure to draw upon. In particular, you might have a parsing routine that&#xD;
    turns strings into parse trees. It would be better at this point to completely rewrite the tests to use it:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
&lt;pre>&#xD;
loop=Parser.parse(&quot;while (i&amp;lt;0) { f(a+i); i++; }&quot;);&#xD;
// Get a pointer to the &quot;a+i&quot; part of the loop. &#xD;
aPlusI = loop.body.statements[0].args[0];&#xD;
expect(false, loop.canHoist(aPlusI));&#xD;
&lt;/pre>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Such tests will be much easier to understand, which will save time immediately and in the future. In fact, their&#xD;
    maintenance costs are so much lower that it might make sense to defer most of them until the parser is available.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There's a slight downside to this approach: such tests might discover a defect in either the transformation code (as&#xD;
    intended) or in the parser (by accident). So problem isolation and debugging may be somewhat more difficult. On the&#xD;
    other hand, finding a problem that the parser tests miss isn't such a bad thing.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There is also a chance that a defect in the parser might mask a defect in the transformation code. The chance of this&#xD;
    is rather small, and the cost from it is almost certainly less than the cost of maintaining the more complicated tests.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;FocusingImprovement&quot; name=&quot;FocusingImprovement&quot;>Focusing test improvement&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A large test suite will contain some blocks of tests that don't change. They correspond to stable areas in the&#xD;
    application. Other blocks of tests will change often. They correspond to areas in the application where behavior is&#xD;
    changing often. These latter blocks of test will tend to make heavier use of utility libraries. Each test will test&#xD;
    specific behaviors in the changeable area. The utility libraries are designed to allow such a test to check its&#xD;
    targeted behaviors while remaining relatively immune to changes in untested behaviors.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For example, the &quot;loop hoisting&quot; test shown above is now immune to the details of how parse trees are built. It is&#xD;
    still sensitive to the structure of a &lt;font size=&quot;+0&quot;>while&lt;/font> loop's parse tree (because of the sequences of&#xD;
    accesses required to fetch the sub-tree for a+i). If that structure proves changeable, the test can be made more&#xD;
    abstract by creating a &lt;font size=&quot;+0&quot;>fetchSubtree&lt;/font> utility method:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
&lt;pre>&#xD;
loop=Parser.parse(&quot;while (i&amp;lt;0) { f(a+i); i++; }&quot;);&#xD;
&lt;b>&#xD;
&lt;i>&#xD;
aPlusI = fetchSubtree(loop, &quot;a+i&quot;);&lt;/i>&lt;/b>&#xD;
expect(false, loop.canHoist(aPlusI));&#xD;
&lt;/pre>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    The test is now sensitive only to two things: the definition of the language (for example, that integers can be&#xD;
    incremented with &lt;font size=&quot;+0&quot;>++&lt;/font>), and the rules governing loop hoisting (the behavior whose correctness it's&#xD;
    checking).&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;ThrowingAwayTests&quot; name=&quot;ThrowingAwayTests&quot;>Throwing away tests&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Even with utility libraries, a test might periodically be broken by behavior changes that have nothing to do with what&#xD;
    it checks. Fixing the test doesn't stand much of a chance of finding a defect due to the change; it's something you do&#xD;
    to preserve the test's chance of finding some other defect someday. But the cost of such a series of fixes might exceed&#xD;
    the value of the test's hypothetically finding a defect. It might be better to simply throw the test away and devote&#xD;
    the effort to creating new tests with greater value.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Most people resist the notion of throwing away a test-at least until they're so overwhelmed by the maintenance burden&#xD;
    that they throw &lt;i>all&lt;/i> the tests away. It is better to make the decision carefully and continuously, test by test,&#xD;
    asking:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        How much work will it be to fix this test well, perhaps adding to the utility library?&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        How else might the time be used?&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        How likely is it that the test will find serious defects in the future? What's been the track record of it and&#xD;
        related tests?&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        How long will it be before the test breaks again?&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    The answers to these questions will be rough estimates or even guesses. But asking them will yield better results than&#xD;
    simply having a policy of fixing all tests.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another reason to throw away tests is that they are now redundant. For example, early in development, there might be a&#xD;
    multitude of simple tests of basic parse-tree construction methods (the &lt;font size=&quot;+0&quot;>LessOp&lt;/font> constructor and&#xD;
    the like). Later, during the writing of the parser, there will be a number of parser tests. Since the parser uses the&#xD;
    construction methods, the parser tests will also indirectly test them. As code changes break the construction tests,&#xD;
    it's reasonable to discard some of them as being redundant. Of course, any new or changed construction behavior will&#xD;
    need new tests. They might be implemented directly (if they're hard to test thoroughly through the parser) or&#xD;
    indirectly (if tests through the parser are adequate and more maintainable).&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
