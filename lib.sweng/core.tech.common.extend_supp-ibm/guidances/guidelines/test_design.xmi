<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-G-ZJ00ODl2UX0VLJTJHCzw" name="test_design,_LwxoYHHUEdyzS55ez-koKA" guid="-G-ZJ00ODl2UX0VLJTJHCzw" changeDate="2007-12-27T11:59:59.796-0800" version="7.2">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Explanation&quot; name=&quot;Explanation&quot;>Explanation&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Nothing has a greater effect on the user's satisfaction with the software than a clear view of what the user expects so&#xD;
    that those expectations can be verified and validated. Test cases reflect the requirements that are to be verified.&#xD;
    Verifying these requirements, however, may be done differently and by different testers. For example, executing the&#xD;
    software to verify its function and performance may be done by a tester using automated test techniques, the shut-down&#xD;
    sequence of a computer system may be done by manual test and observation, while market share and sales, (also product&#xD;
    requirements), will be done by measuring product and competitive sales.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Since you may not be able to (or be responsible to) verify all requirements, it is critical for the success of your&#xD;
    project to select the most appropriate or critical ones requirements for test. The requirements you choose to verify&#xD;
    will be a balance between the cost, risk, and necessity of having the requirement verified.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Identifying the test cases is important for several reasons.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Test cases form the foundation on which to design and develop Test Scripts.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The &quot;depth&quot; of the testing is proportional to the number of test cases. Greater confidence in the quality of the&#xD;
        product and test process is gained when the number of test cases increases, since each test case reflects a&#xD;
        different scenario, condition, or flow through the product.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A principal measure of the completeness of test is requirements-based coverage, based on the of the number test&#xD;
        cases identified, implemented, and / or executed. A statement such as &quot;95 percent of our critical test cases have&#xD;
        been executed and verified&quot; is more significant than stating &quot;We're 95 percent of the way through our tests.&quot;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The scale of the test effort is proportional to the number of test cases. With a comprehensive breakdown of test&#xD;
        cases, the timing of succeeding stages of the test cycle can be more accurately estimated.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The kinds of test design and development, and the resources needed are largely governed by the test cases.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Test cases are often categorized or classified by the type of test or requirement for test they are associated with,&#xD;
    and will vary accordingly. The practice is to develop at least two test cases for each requirement for test:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A test case which will demonstrate the requirement has been achieved. This is called a positive test case.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Another test case, reflecting an unacceptable, abnormal, or unexpected condition or data, to demonstrate that the&#xD;
        requirement is only achieved under the desired condition, referred to as a negative test cases.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;DerivingTestCasesforUnitTest&quot; name=&quot;DerivingTestCasesforUnitTest&quot;>Deriving Test Cases for Unit Test&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Unit testing requires testing both the unit's internal structure and its behavioral characteristics. Testing the&#xD;
    internal structure requires a&amp;nbsp; knowledge of how the unit is implemented, and tests based upon this knowledge are&#xD;
    known as white-box tests. Testing a unit's behavioral characteristics focuses on the external observable behaviors of&#xD;
    the unit without knowledge or regard its implementation. Tests based upon this approach are referred to as black-box&#xD;
    tests. Deriving test cases based upon both approaches are described below.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;WhiteBox_tests&quot; name=&quot;WhiteBox_tests&quot;>White-Box Tests&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Theoretically, you should test every possible path through the code. Achieving such a goal, in all but very simple&#xD;
    units, is either impractical or almost impossible. At the very least you should exercise every &lt;b>decision-to-decision&#xD;
    path&lt;/b> (DD-path) at least once, resulting in executing all statements at least once. A decision is typically an&#xD;
    if-statement, and a DD-path is a path between two decisions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To get this level of test coverage, it is recommended that you choose test data so that every decision is evaluated in&#xD;
    every possible way. Toward that end, the test cases should make sure that:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Every Boolean expression is evaluated to &lt;b>true&lt;/b> and &lt;b>false&lt;/b>. For example the expression (a&amp;lt;3) OR&#xD;
        (b&amp;gt;4) evaluates to four combinations of &lt;b>true&lt;/b>/&lt;b>false&lt;/b>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Every infinite loop is exercised at least zero times, once, and more than once.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Use code-coverage tools to identify the code not exercised by your white box testing. Reliability testing should be&#xD;
    done simultaneously with your white-box testing.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Assume that you perform a structure test on a function &lt;b>member&lt;/b> in the class &lt;b>Set of Integers.&lt;/b> The test -&#xD;
    with the help of a binary search - checks whether the set contains a given integer.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;200&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;./resources/untst001.gif&quot; width=&quot;301&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The member function and its corresponding flowchart. Dotted arrows illustrate how you can use two test cases to execute&#xD;
    all the statements at least once.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Theoretically, for an operation to be thoroughly tested, the test case should traverse all the combinations of routes&#xD;
    in the code. In &lt;b>member&lt;/b>, there are three alternative routes inside the &lt;b>while-loop&lt;/b>. The test case can&#xD;
    traverse the loop either several times or not at all. If the test case does not traverse the loop at all, you will find&#xD;
    only one route through the code. If it traverses the loop once, you will find three routes. If it traverses twice, you&#xD;
    will find six routes, and so forth. Thus, the total number of routes will be 1+3+6+12+24+48+..., which in practice, is&#xD;
    an unmanageable number of route combinations. That is why you must choose a subset of all these routes. In this&#xD;
    example, you can use two test cases to execute all the statements. In one test case, you might choose &lt;code>&lt;b>Set of&#xD;
    Integers&lt;/b> = {1,5,7,8,11}&lt;/code> and &lt;code>&lt;b>t&lt;/b> = 3&lt;/code> as test data. In the other test case, you might choose&#xD;
    &lt;code>&lt;b>Set of Integers&lt;/b> = {1,5,7,8,11}&lt;/code> and &lt;code>&lt;b>t&lt;/b> = 8&lt;/code>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;BlackBox_Tests&quot; name=&quot;BlackBox_Tests&quot;>Black-Box Tests&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The purpose of a black-box test is to verify the unit's specified behavior without looking at &lt;b>how&lt;/b> the unit&#xD;
    implements that behavior. Black-box tests focus and rely upon the unit's input and output.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Equivalence partitioning&lt;/b> is a technique for reducing the required number of tests. For every operation, you&#xD;
    should identify the equivalence classes of the arguments and the object states. An &lt;b>equivalence class&lt;/b> is a set of&#xD;
    values for which an object is supposed to behave similarly. For example, a &lt;b>Set&lt;/b> has three equivalence classes:&#xD;
    &lt;b>empty&lt;/b>, &lt;b>some element,&lt;/b> and &lt;b>full&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Use code-coverage tools to identify the code not exercised by your white box testing. Reliability testing should be&#xD;
    done simultaneously with your black-box testing.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The next two subsections describe how to identify test cases by selecting test data for specific arguments.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Test Cases based upon Input Arguments&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    An &lt;b>input argument&lt;/b> is an argument used by an operation. You should create test cases by using input arguments for&#xD;
    each operation, for each of the following input conditions:&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Normal values from each equivalence class.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Values on the boundary of each equivalence class.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Values outside the equivalence classes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Illegal values.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Remember to treat the object state as an input argument. If, for example, you test an operation &lt;b>add&lt;/b> on an object&#xD;
    &lt;b>Set&lt;/b>, you must test &lt;b>add&lt;/b> with values from all of &lt;b>Set&lt;/b>'s equivalence classes, that is, with a full&#xD;
    &lt;b>Set&lt;/b>, with some element in &lt;b>Set,&lt;/b> and with an empty &lt;b>Set&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Test Cases based upon Output Arguments&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    An &lt;b>output argument&lt;/b> is an argument that an operation changes. An argument can be both an input and an output&#xD;
    argument. Select input so that you get &lt;b>output&lt;/b> according to each of the following.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Normal values from each equivalence class.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Values on the boundary for each equivalence class.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Values outside the equivalence classes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Illegal values.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Remember to treat the object state as an output argument. If for example, you test an operation &lt;b>remove&lt;/b> on a&#xD;
    &lt;b>List&lt;/b>, you must choose input values so that &lt;b>List&lt;/b> is full, has some element, and is empty after the&#xD;
    operation is performed (test with values from all its equivalence classes).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the object is state-controlled (reacts differently depending on the object's state), you should use a state matrix&#xD;
    such as the one in the following figure.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;166&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;./resources/untst002.gif&quot; width=&quot;184&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    A state matrix for testing. You can test all combinations of state and stimuli on the basis of this matrix.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
