<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ArtifactDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-U5Wgjvr2z8JsIkUyKllFWw" name="component_model,_YLmNgM5FEdu7c6SGcTVf1A" guid="-U5Wgjvr2z8JsIkUyKllFWw" changeDate="2008-09-16T10:30:38.629-0700" version="7.1.0">
  <mainDescription>&lt;p>&#xD;
    The component model describes the structure of a system in terms of its software components with their&#xD;
    responsibilities, interfaces, relationships, and the way they collaborate to deliver the required functionality. The&#xD;
    component model is the main artifact documenting the functional view of the architecture and serves as an abstraction&#xD;
    of the design. Components identified may be decomposed into further component models before they complete the&#xD;
    specification required for detailed design.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Component models help define and document:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The structure of the system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The recurring interactions and dependencies between sets of components&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The components present within an enterprise, each of which may be made up of smaller components.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models are documented at 2 levels:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The logical level - focuses on specifying the components' responsibilities and characteristics required to deliver&#xD;
        the requirements. These specifications are technology and product neutral.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The physical level -focuses on how to implement the components to meet the previously established specifications.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You may transform logical components into physical components via custom development, the purchase of products, or the&#xD;
    reuse of assets.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It may be important to maintain a separation between logical and physical components on larger projects. However,&#xD;
    smaller or less complex projects may evolve a single logical component model into a physical model, and end up with&#xD;
    only a physical model.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Examples of components at the logical level are a 'Message Bus' or a 'Customer Relationship Manager' component.&#xD;
    Components at the physical level that implement these logical components might be 'IBM WebSphere Message Broker' or&#xD;
    'Siebel Contact Center.'&lt;br />&#xD;
&lt;/p></mainDescription>
  <keyConsiderations>&lt;p>&#xD;
    Points to consider when deciding whether to use a Component Model:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A Component Model is useful when you must design the system for multiple target environments, with separate design&#xD;
        architectures. The Component Model is an abstraction, or a generalization, of the system design. It omits most of&#xD;
        the details of the design in order to provide an overview of the system's functionality.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Component Model provides value when the design is complex, such that new team members need a simplified,&#xD;
        abstracted model to understand it. A well-defined architecture can serve the same purpose.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Balance the extra work required to ensure that the component and design models remain consistent against the&#xD;
        benefit of having a view of the system that represents only the most important details of how the system works. It&#xD;
        can be very costly to maintain a high degree of fidelity between the Component Model and the system design. A less&#xD;
        ambitious approach might be to maintain the Component Model with only the most important components and the key&#xD;
        abstractions in the design. As the complexity of the Component Model increases, so does the cost to maintain it.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you no longer maintain the Component Model, its value decays rapidly. At some point, it no longer accurately&#xD;
        reflects the current functional design of the system. Deciding to no longer maintain the Component Model may be&#xD;
        appropriate, as it may have served its purpose, but the decision should be a conscious one.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Component models tend to be useful in companies where systems live for decades, or where there are many variants of the&#xD;
    system.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To ensure the successful development of a component model on a project, your team should:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Create a stable and coherent structure&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Focus on the right levels of abstraction&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Develop relationship and interaction diagrams in parallel&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Select architecturally significant requirements as inputs to the Component Model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Plan how your team will leverage the Component Model throughout the project lifecycle&#xD;
    &lt;/li>&#xD;
&lt;/ul></keyConsiderations>
  <purpose>&lt;p>&#xD;
    The purpose of the component model is to help organize projects, manage the complexity of the solution, and ensure that&#xD;
    all architecturally requirements have been addressed. It helps developers design and implement the solution and&#xD;
    understand the big picture of the system design.&#xD;
&lt;/p></purpose>
  <impactOfNotHaving>&lt;p>&#xD;
    It is difficult to gain an understanding of the structure of a complex system without some kind of component&#xD;
    model.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The absence of this artifact may result in:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Difficulty managing the development project&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The need for individual designers and developers to understand most of the inner details of the entire system&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Difficulty managing parallel development due to imprecise definitions of the work allocated to development groups&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Missed opportunities for reuse of high level components&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        An incomplete design with key design elements missing&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Lack of information (such as the relevant service level requirements) essential to the appropriate placement of&#xD;
        applications and data across the system infrastructure&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Difficulty tracing requirements through implementation and validating that the architecturally significant&#xD;
        requirements are realized in the executable architecture&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></impactOfNotHaving>
  <reasonsForNotNeeding>&lt;p>&#xD;
    A Component Model may not be necessary when:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The overall system to be developed is quite small&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The functional view of the overall system can be adequately described in some other form, as may be the case with a&#xD;
        simple package-based organization of the architecture&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></reasonsForNotNeeding>
  <briefOutline>&lt;p>&#xD;
    The Component Model consists of:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Introduction.&lt;/strong> Describes the context, purpose, scope, and intended audience of the component model.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Model Overview.&lt;/strong> Explains how the model has been organized, particularly if several component&#xD;
        models were built.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Notation.&lt;/strong> If appropriate, describes any notation used in the document.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Overview of Layers and Subsystems.&lt;/strong> May describe logical components and/or physical components.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Component Relationship Diagrams.&lt;/strong> Shows the relationships between components.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Component Interaction Diagrams.&lt;/strong> Describes the collaboration between components.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Component Descriptions.&lt;/strong> Describes in detail each component's responsibilities and interfaces,&#xD;
        required service levels (non-functional requirements), risk, design rationale, and implementation approach.&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></briefOutline>
  <representationOptions>&lt;p>&#xD;
    Ideally, you should represent component models using a UML modeling tool that supports the UML 2 notation defined for&#xD;
    this artifact. Modeling tools help ensure consistency between models and between the various diagrams they contain by&#xD;
    allowing model elements to be shared among many models or diagrams. These tools also allow multiple views of the same&#xD;
    model.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Alternatively, you can represent component models through a series of stand-alone diagrams developed in diagramming&#xD;
    tools, then bound together within a word-processing document. A diagramming tool is difficult to maintain if any model&#xD;
    element appears in multiple diagrams, as changes to the model element must be made in each diagram on which it appears.&#xD;
    These tools may be appropriate for smaller projects in which the development and maintenance of the component model is&#xD;
    limited in scope, resources and effort. However, this approach is impractical for a team of practitioners responsible&#xD;
    for maintaining an up-to-date component model that interoperates with other models, such as the requirements and&#xD;
    operational models.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Whichever option you choose, do not underestimate the importance of using a common notation and standard like UML 2.&#xD;
    All diagrams, irrespective of representation option, should use formal notation, and UML 2 is recommended.&lt;br />&#xD;
&lt;/p></representationOptions>
  <representation>&lt;p>&#xD;
    A UML modeling tool is the preferred method for developing the component model. UML 2.0 is the standard notation.&#xD;
&lt;/p></representation>
  <notation>&lt;p>&#xD;
    The different kinds of diagrams and their associated notation used in documenting the Component Model are summarized&#xD;
    below.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Component Relationship Diagram&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A Component Relationship Diagram shows the static dependency relationships between components or subsystems.&lt;br />&#xD;
    &lt;img height=&quot;361&quot; alt=&quot;Component Diagram&quot; src=&quot;./resources/component_diagram.gif&quot; width=&quot;546&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xD;
    Figure 1 - Component Relationship Diagram&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Component Interaction Diagram&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A Component Interaction Diagram shows the interactions between individual component instances and how a number of such&#xD;
    component instances collaborate together to realize a scenario. Interaction diagrams also show the sequential flow of&#xD;
    messages over time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img height=&quot;294&quot;     alt=&quot;Component Interaction Diagram&quot; src=&quot;./resources/component_interaction_diagram.gif&quot; width=&quot;600&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xD;
    Figure 2 - Component Interaction Diagram&#xD;
&lt;/p></notation>
</org.eclipse.epf.uma:ArtifactDescription>
