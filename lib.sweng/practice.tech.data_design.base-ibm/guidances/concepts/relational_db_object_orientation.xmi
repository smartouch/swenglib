<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-EMH4RA5ELwJ098DJ0gvkIQ" name="relational_databases_and_object_orientation,_SxF-QAo-Edygr55FhBZqVw" guid="-EMH4RA5ELwJ098DJ0gvkIQ" changeDate="2011-07-27T15:11:18.234-0700" version="1.0.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>&lt;/a>Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This concept document provides an overview of object models and relational data models, and provides a summary&#xD;
    description of a persistence framework.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Relational Databases and Object Orientation&quot; name=&quot;Relational Databases and Object Orientation&quot;>&lt;/a>Relational&#xD;
    Databases and Object Orientation&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Relational databases and object orientation are not entirely compatible. They represent two different views of the&#xD;
    world: in an RDBMS, all you see is data; in an Object-Oriented system, all you see is behavior. It is not that one&#xD;
    perspective is better than the other: the Object-Oriented model tends to work well for systems with complex behavior&#xD;
    and state-specific behavior in which data is secondary, or systems in which data is accessed navigationally in a&#xD;
    natural hierarchy (for example, bills of materials). The RDBMS model is well-suited to reporting applications and&#xD;
    systems in which the relationships are dynamic or ad-hoc.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The real fact of the matter is that a lot of information is stored in relational databases, and if Object-Oriented&#xD;
    applications want access to that data, they need to be able to read and write to an RDBMS. In addition, Object-Oriented&#xD;
    systems often need to share data with non-Object-Oriented systems. It is natural, therefore, to use an RDBMS as the&#xD;
    sharing mechanism.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    While object-oriented and relational design share some common characteristics (an objects attributes is conceptually&#xD;
    similar to an entities columns), fundamental differences make seamless integration a challenge. The fundamental&#xD;
    difference is that data models expose data (through column values) while object models hide data (encapsulating it&#xD;
    behind its public interfaces).&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;The Relational Data Model&quot; name=&quot;The Relational Data Model&quot;>The Relational Data Model&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The relational model is composed of entities and relations. An entity may be a physical table or a logical projection&#xD;
    of several tables also known as a view. The figure below illustrates LINEITEM, ORDER, and PRODUCT tables and the&#xD;
    various relationships between them. A relational model has the following elements:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &amp;nbsp;&lt;img alt=&quot;Relational Database Elements&quot; src=&quot;resources/relational_data_model_elements.gif&quot; width=&quot;440&quot;&#xD;
    height=&quot;164&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    A Relational Model&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An entity has columns. Each column is identified by a name and a type. In the figure above, the LINEITEM entity has the&#xD;
    columns LineItem_Id (the primary key), Description, Price, Quantity, Product_Id and Order_Id (the latter two are&#xD;
    foreign keys that link the LINEITEM entity to the ORDER and PRODUCT entities).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An entity has records or rows. Each row represents a unique set of information which typically represents an object's&#xD;
    persistent data.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Each entity has one or more primary keys. The primary keys uniquely identify each record (for example, Id is the&#xD;
    primary key for LINEITEM table).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Support for relations is vendor specific. The example illustrates the logical model and the relation between the&#xD;
    PRODUCT and LINEITEM tables. In the physical model, relations are typically implemented using foreign key / primary key&#xD;
    references. If one entity relates to another, it will contain columns which are foreign keys. Foreign key columns&#xD;
    contain data which can relate specific records in the entity to the related entity.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Relations have multiplicity (also known as cardinality). Common cardinalities are one to one (1:1), one to many (1:m),&#xD;
    many to one (m:1), and many to many (m:n). In the example, LINEITEM has a 1:1 relationship with PRODUCT and PRODUCT has&#xD;
    a 0:m relationship with LINEITEM.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;The Object Model&quot; name=&quot;The Object Model&quot;>The Object Model&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An object model contains, among other things, classes a complete definition of an object model). Classes define the&#xD;
    structure and behavior of a set of objects, sometimes called objects &lt;strong>instances&lt;/strong>. The structure is&#xD;
    represented as attributes (data values) and associations (relationships between classes). The following figure&#xD;
    illustrates a simple class diagram, showing only attributes (data) of the classes.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &amp;nbsp;&lt;img alt=&quot;Class Diagram&quot; src=&quot;resources/class_diagarm_rel_data_modeling.gif&quot; width=&quot;446&quot; height=&quot;364&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    An Object Model (Class Diagram)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An Order has a number (the Order Number), and an association to 1 or more (1..*) Line Items. Each Line Item has a&#xD;
    quantity (the quantity ordered).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The object model supports inheritance. A class can inherit data and behavior from another class (for example,&#xD;
    SoftwareProduct and HardwareProduct products inherit attributes and methods from Product class).&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Persistence Frameworks&quot; name=&quot;Persistence Frameworks&quot;>Persistence Frameworks&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The majority of business applications utilize relational technology as a physical data store. The challenge facing&#xD;
    object-oriented applications developers is to sufficiently separate and encapsulate the relational database so that&#xD;
    changes in the data model do not &quot;break&quot; the object model, and vice versa. Many solutions exist which let applications&#xD;
    directly access relational data; the challenge is in achieving a seamless integration between the object model and the&#xD;
    data model.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Database application programming interfaces (APIs) come in standard flavors (for example, Microsoft's Open Data Base&#xD;
    Connectivity API, or ODBC) and are proprietary (native bindings to specific databases). The APIs provide data&#xD;
    manipulation language (DML) pass through services which allow applications to access raw relational data. In&#xD;
    object-oriented applications, the data must undergo object-relational translation prior to being used by the&#xD;
    application. This requires considerable amount of application code to translate raw database API results into&#xD;
    application objects. The purpose of the object-relational framework is to generically encapsulate the physical data&#xD;
    store and to provide appropriate object translation services.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &amp;nbsp;&lt;img alt=&quot;Persistence Frameworks&quot; src=&quot;resources/persistance_frameworks.gif&quot; width=&quot;266&quot; height=&quot;242&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The Purpose of a Persistence Framework&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Application developers spend over 30% of their time implementing relational database access in object-oriented&#xD;
    applications. If the object-relational interface is not correctly implemented, the investment is lost. Implementing an&#xD;
    object-relational framework captures this investment. The object-relational framework can be reused in subsequent&#xD;
    applications reducing the object-relational implementation cost to less than 10% of the total implementation costs. The&#xD;
    most important cost to consider when implementing any system is maintenance. Over 60% percent of the total costs of a&#xD;
    system over its entire life-cycle can be attributed to maintenance. A poorly implemented object relational system is&#xD;
    both a technical and financial maintenance nightmare.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Essential characteristics of an object-relational framework&quot;&#xD;
    name=&quot;Essential characteristics of an object-relational framework&quot;>Essential characteristics of an object-relational&#xD;
    framework&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Performance&lt;/strong>. Close consideration must be given towards decomposing objects into data and composing&#xD;
        objects from data. In systems where data through-put is high and critical, this is often an Achilles heel of an&#xD;
        inadequately designed access layer.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Minimize design compromises&lt;/strong>. A familiar pattern to object technologists who have built systems,&#xD;
        which utilize relational databases, is to adjust the object model to facilitate storage into relational systems,&#xD;
        and to alter the relational model for easier storage of objects. While minor adjustments are often needed, a well&#xD;
        designed access layer minimizes both object and relational model design degradation.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Extensibility&lt;/strong>. The access layer is a white-box framework which allows application developers to&#xD;
        extend the framework if certain functionality is desired in the framework. Typically, an access layer will support,&#xD;
        without extension, 65-85% of an application's data storage requirements. If the access layer is not designed as an&#xD;
        extensible framework, achieving the last 35-15% of an application's data storage requirements can be very difficult&#xD;
        and costly.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Documentation&lt;/strong>. The access layer is a both a black-box component, and a white-box framework. The&#xD;
        API of the black-box component must be clearly defined, well documented, and easily understood. As previously&#xD;
        mentioned, the access layer is designed to be extended. An extensible framework must be very thoroughly documented.&#xD;
        Classes which are intended to be subclassed must be identified. The characteristics of each relevant class's&#xD;
        protocol must be specified (for example, public, private, protected, final, ...). Moreover, a substantial portion&#xD;
        of the access layer framework's design must be exposed and documented to facilitate extensibility.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Support for common object-relational mappings&lt;/strong>. An access layer should provide support for some&#xD;
        basic object-relational mappings without the need for extension. These object-relational mappings are discussed&#xD;
        further in a subsequent section of this document.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Persistence Interfaces&lt;/strong>: In an object oriented application, the business model for an object&#xD;
        application captures semantic knowledge of the problem domain. Developers should manipulate and interact with&#xD;
        objects without having to worry too much about the data storage and retrieval details. A well-defined subset of&#xD;
        persistent interfaces (save, delete, find) should be provided to application developers.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Common Object-Relational Services&quot; name=&quot;Common Object-Relational Services&quot;>Common Object-Relational&#xD;
    Services&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Common patterns are emerging for object-relational applications. IT professionals who have repeatedly crossed the chasm&#xD;
    are beginning to understand and recognize certain structures and behaviors which successful object-relational&#xD;
    applications exhibit. These structures and behaviors have been formalized by the high-level CORBA Services&#xD;
    specifications (which apply equally well to COM/DCOM-based systems).&lt;br />&#xD;
    &lt;br />&#xD;
    The CORBA service specifications which are applicable and useful to consider for object-relational mapping are the&#xD;
    following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Persistence.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Query.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Transactions.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Concurrency.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Relationships.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The following sections will use these categories to structure a discussion of common object-relational services. The&#xD;
    reader is encouraged to reference the appropriate CORBA specifications for further details.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Persistence&quot; name=&quot;Persistence&quot;>Persistence&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Persistence is a term used to describe how objects utilize a secondary storage medium to maintain their state across&#xD;
    discrete sessions. Persistence provides the ability for a user to save objects in one session and access them in a&#xD;
    later session. When they are subsequently accessed, their state (for example, attributes) will be exactly the same as&#xD;
    it was the previous session. In multi-user systems, this may not be the case since other users may access and modify&#xD;
    the same objects. Persistence is interrelated with other services discussed in this section. The consideration of&#xD;
    relationship, concurrency and others is intentional (and consistent with CORBA's decomposition of the services).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Examples of specific services provided by persistence are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Data source connection management&lt;/strong>: Object-relational applications must initiate connection to the&#xD;
        physical data source. Relational database systems typically require identification of the server and database. The&#xD;
        specifics of connection management tends to be database vendor specific and the framework must accordingly be&#xD;
        designed in a flexible accommodating manner.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Object retrieval&lt;/strong>: When objects are restored from the database, data is retrieved from the database&#xD;
        and translated into objects. This process involves extracting data from database specific structures retrieved from&#xD;
        the data source, marshaling the data from database types into the appropriate object types and/or classes, creation&#xD;
        of the appropriate object, and setting the specific object attributes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Object storage&lt;/strong>: The process of object storage mirrors object retrieval. The values of the&#xD;
        appropriate attributes are extracted from the object, a database specific structure is created with the attribute&#xD;
        values (this may be a SQL string, stored procedure, or special remote procedure call), and the structure is&#xD;
        submitted to the database.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Object deletion&lt;/strong>: Objects that are deleted from within a system, must have their associated data&#xD;
        deleted from the relational database. Object deletion requires that appropriate information be extracted from the&#xD;
        object, a deletion request be constructed (this may be a SQL string, stored procedure, or special remote procedure&#xD;
        call), and the request submitted to the database. Note that in some languages (for example, Smalltalk and Java),&#xD;
        explicit deletion is not supported; instead, a strategy called &lt;strong>garbage collection&lt;/strong> is supported.&#xD;
        Persistence frameworks supporting these languages must provide an alternative way to remove data from the database&#xD;
        once applications no longer reference the data. One common way is for the database to maintain&#xD;
        &lt;strong>reference-counts&lt;/strong> of the number of times an object is referenced by other objects. When the&#xD;
        reference count for an object drops to zero, no other objects reference it, and it &lt;strong>may&lt;/strong> be possible&#xD;
        to delete it. It &lt;strong>may be acceptable&lt;/strong> to delete objects with a reference count of zero, since even&#xD;
        when an object is no longer referenced, it may still be queried. A database-wide policy on when object deletion is&#xD;
        allowed is still needed.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Query&quot; name=&quot;Query&quot;>Query&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Persistent object storage is of little use without a mechanism to search for and retrieve specific objects. Query&#xD;
    facilities allow applications to interrogate and retrieve objects based on a variety of criteria. The basic query&#xD;
    operations provided by an object-relational mapping framework are find and find unique. The find unique operation will&#xD;
    retrieve a specific object and find will return a collection of objects based on a query criteria.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Data store query facilities vary significantly. Simple file-based data stores may implement rigid home-grown query&#xD;
    operations, while relational systems provide a flexible data manipulation language. Object-relational mapping&#xD;
    frameworks extend the relational query model to make it object-centric rather than data centric. Pass-through&#xD;
    mechanisms are also implemented to leverage relational query flexibility and vendor-specific extensions (for example,&#xD;
    stored-procedures).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that there is some potential conflict between database-based query mechanisms and the object paradigm: database&#xD;
    query mechanisms are driven by &lt;strong>values&lt;/strong> of attributes (columns) in a table. In the corresponding&#xD;
    objects, the principle of encapsulation prevents us from seeing the values of attributes; they are&#xD;
    &lt;strong>encapsulated&lt;/strong> by the operations of the class. The reason for encapsulation is that it makes&#xD;
    applications easier to change: we can alter the internal structure of a class without concern for dependent classes as&#xD;
    long as the publicly-visible operations of the class do not change. A query mechanism based on the database is&#xD;
    dependent on the internal representation of a class, effectively &lt;strong>breaking&lt;/strong> encapsulation. The challenge&#xD;
    for the framework is to prevent queries from making applications brittle to change.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Transactions&quot; name=&quot;Transactions&quot;>Transactions&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Transactional support enables the application developer to define an atomic unit of work. In database terminology, it&#xD;
    means that the system must be able to apply a set of changes to the database, or it must ensure that none of the&#xD;
    changes are applied. The operations within a transaction either all execute successfully or the transaction fails as&#xD;
    whole. Object-relational frameworks at a minimum should provide a relational database-like commit/rollback transaction&#xD;
    facility. Designing object-relational frameworks in a multi-user environment can present many challenges and careful&#xD;
    thought should be given to it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In addition to the facilities provided by the persistence framework, the application must understand how to handle&#xD;
    errors. When a transaction fails or is aborted, the system must be able to restore its state to a stable prior state,&#xD;
    usually by reading the prior state information from the database. Thus, there is a close interaction between the&#xD;
    persistence framework and the error handling framework.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Concurrency&quot; name=&quot;Concurrency&quot;>Concurrency&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Multi-user object-oriented systems must control concurrent access to objects. When an object is accessed simultaneously&#xD;
    by many users, the system must provide a mechanism to insure modifications to the object in the persistent store occur&#xD;
    in a predictable and controlled manner. Object-relational frameworks may implement pessimistic and/or optimistic&#xD;
    concurrency controls.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Pessimistic concurrency control&lt;/strong> requires that the application developer specify their intent when&#xD;
        the object is retrieved from the data store (for example, read only, write lock, ...). If objects are locked, other&#xD;
        users may block when accessing the object and wait for the lock to be relinquished. Pessimistic concurrency should&#xD;
        be used and implemented with caution as it is possible to create dead-lock situations.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Optimistic concurrency control&lt;/strong> assumes that it is unlikely that the same object will be&#xD;
        simultaneously accessed. Concurrency conflicts are detected when the modifications are saved to the database.&#xD;
        Typically, if the object has been modified by another user since its retrieval, an error will be returned to the&#xD;
        application indicating failure of the modify operation. It is the application's responsibility to detect and handle&#xD;
        the error. This calls for the framework to cache the concurrent values of objects and compare them against the&#xD;
        database. Optimistic concurrency is less costly if there are few concurrency conflicts, but more expensive if the&#xD;
        number of conflicts is fairly large (because of the need to re-do work when conflicts occur).&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    All applications using shared data must use the same concurrency strategy; you cannot mix optimistic and pessimistic&#xD;
    concurrency control in the same shared data or corruption may occur. The need for a consistent concurrency strategy is&#xD;
    best handled through a persistence framework.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Relationships&quot; name=&quot;Relationships&quot;>Relationships&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Objects have relationships to other objects. An Order object has many Line Item objects. A Book object has many Chapter&#xD;
    objects. An Employee object belongs to exactly one Company object. In relational systems, relations between entities&#xD;
    are implemented using foreign key / primary key references. In object-oriented systems, relations are usually&#xD;
    explicitly implemented through attributes. If an Order object has LineItems, then Order will contain an attribute named&#xD;
    lineItems. The lineItems attribute of Order will contain many LineItem objects.&lt;br />&#xD;
    &lt;br />&#xD;
    The relationship aspects of an object-relational framework are interdependent with the persistence, transaction, and&#xD;
    query services. When an object is stored, retrieved, transacted, or queried, consideration must be given to its related&#xD;
    objects:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        When an object is retrieved, should associated objects be retrieved as well? Simplistically, yes, but doing so when&#xD;
        the associated objects are not needed is very expensive. A good framework will allow a mix of strategies.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        When an object is stored, should associated objects be stored as well if they have been changed? Again, the answer&#xD;
        depends on the context.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    While it is conceptually advantageous to consider common object-relational services separately, their object-relational&#xD;
    framework implementations will be co-dependent. The services must be implemented consistently across not only&#xD;
    individual organizations, but all applications which share the same data. A framework is the only economical way to&#xD;
    achieve this.&#xD;
&lt;/p>&lt;br /></mainDescription>
  <externalId xsi:nil="true"/>
  <keyConsiderations xsi:nil="true"/>
</org.eclipse.epf.uma:ContentDescription>
