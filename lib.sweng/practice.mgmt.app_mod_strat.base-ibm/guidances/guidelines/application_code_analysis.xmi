<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-rJTPTwpUXNyVzCFNOs6G1Q" name="new_guideline,_OEmugMQPEd6Ru5xIwF9Xnw" guid="-rJTPTwpUXNyVzCFNOs6G1Q" changeDate="2011-07-27T12:41:24.234-0700" version="7.5.0">
  <mainDescription>&lt;p>&#xD;
    Application code analysis regarding this practice is static code analysis that requires reading of code through&#xD;
    analysis tools, to understand the structure of the application with associated metrics (Complexity, size â€¦ etc). This&#xD;
    analysis can also lead to uncovering the cause of issues/concerns with the application as raised by the stake holders.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Static code analysis&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Static code analysis is the analysis of software source code that is performed without actually executing the&#xD;
    application program. Static analysis involves using automated tools to analyze and understand code structure on what&#xD;
    this application can do on a potential execution. This allows the analyst to create diagrammatic or graphical&#xD;
    representations of the code, which gives them a better understanding of the executed code's effects.&lt;br />&#xD;
    &lt;br />&#xD;
    Automated analysis tools are preferred as compare to manual code reading as manual reading can be very time consuming.&#xD;
    In addition, to perform a manual analysis effectively, the code analyst must first know what vulnerabilities look like&#xD;
    before they can rigorously examine the code. Static analysis tools compare favorably to manual analysis because they&#xD;
    are faster, can be utilized to evaluate programs much more frequently, and can encapsulate more knowledge in a way that&#xD;
    does not require the tool operator to have the same level of expertise as a human analyst. On the other hand, these&#xD;
    tools cannot replace a human analyst; they can only speed up those tasks that are easily automated. However, tools are&#xD;
    very good at producing artifacts for the following:&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Application governance&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Change analysis&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Reports for project estimation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Lists and diagrams for program understanding&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Data flow analysis&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Test planning&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Application understanding,&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Componentization of the application&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Detail interfaces with &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Data stores&amp;nbsp;&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Transaction&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Other application&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                etc&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Metrics &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Complexity&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Lines of code&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Functionality&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                etc&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Metrics&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Analysis of metrics generated by source code analysis tools provide&amp;nbsp;measure of the degree to which the code under&#xD;
    consideration possesses a given attribute. An attribute is a&amp;nbsp;property of the code.&lt;br />&#xD;
    &lt;br />&#xD;
    Metrics provide analyst with critical insight into the application. When considered separately, a metric such as the&#xD;
    number of defects per 1000 lines of code provides very little business or technical meaning. However, a metric such as&#xD;
    the complexity value of source code artifact, where higher the number means more complexity, provides a much more&#xD;
    useful and interesting relative value. It can be used to compare and contrast a given system's complexity and defect&#xD;
    density and thus provides analyst useful data that can lead to problem areas quickly.&lt;br />&#xD;
    &lt;br />&#xD;
    Source code analysis tools provide array of different matrices that provide vital information on application source&#xD;
    code structure. Practical implementation can use larger set of matrices that can provide significant incite into the&#xD;
    structure of application under consideration. To understand the structure of an application, metrics need to be collect&#xD;
    at different artifact level. Different artifact level exists in source code structure such as modules, files, screens,&#xD;
    handlers, libraries etc. The most common metrics provided by various tools are&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Complexity&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Functionality distribution&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Use (artifact used by other artifacts)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Lines of code&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Defect possibility&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Collected metrics can be combine with data collected in current state analysis to validate perceived issues with the&#xD;
    application. Some of the metrics can also uncover root cause of issues that stake holders report they have with the&#xD;
    application. For example if the issue is lot of defects in a particular area then combination of Lines of code,&#xD;
    Complexity and Defect possibility can rule if the problem is with the structure of that particular part of application.&#xD;
    Here functional density can give an incite if there is a need to distribute or break functionality provided by this&#xD;
    part into more manageable part each providing portion of functionality.&lt;br />&#xD;
    &lt;br />&#xD;
    Collected metrics data combined with other analysis data (data flow, change analysis, interfaces etc) aids the&#xD;
    architects in understanding the over all structure of the application and will help identify road map that has lowest&#xD;
    risk to achieve organization goal. Determining a particular road map out of the data select is still subjective and&#xD;
    depends on how effectively collected data is interpreted. However, selected road map can be further analyzed by doing&#xD;
    selective analysis.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Selective analysis&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    To achieve the goal of this practice, that is &quot;determine application modernization strategy&quot; will require frequent and&#xD;
    deep analysis of various defined parts of the application. Most common part that contributes in determining a strategy&#xD;
    is the application interface with other applications, data stores, user, third party code etc. It is important to&#xD;
    define a boundary for the application before deep analysis is performed. Having a defined boundary aids in&#xD;
    identification of interfaces of the application. It is uncommon but not rare to include previously identified external&#xD;
    artifacts in the application boundary. Care is required to include external artifacts only when it helps defining a&#xD;
    modernization strategy or alternative. Avoid temptation to include external artifacts to simplify analysis as this can&#xD;
    easily increase the scope of analysis beyond an application.&lt;br />&#xD;
    &lt;br />&#xD;
    Most common deep analysis used is impact analysis for a change. Impact analysis will help determine what will be&#xD;
    impacted by change as one progress on steps of a given road map and associated strategy. Impact analysis can quickly&#xD;
    determine what need to change and what would be the complexity associated with that change. Number of impact analysis&#xD;
    will be required to determine all the change complexity for a given road map. However, trend can quickly be determined&#xD;
    what is the risk associated with a particular road map.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Input:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Project initiation is complete&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Application has been identified&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Source code is delivered&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Developers are available to work with assessment team on this study&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Output:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Detail architecture structure of the application&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Validation of strategy that has least complexity and risk&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
