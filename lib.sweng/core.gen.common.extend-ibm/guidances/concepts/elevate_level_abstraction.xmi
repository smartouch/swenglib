<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-9g8xnjUVLPiqPjthH_Tp3Q" guid="-9g8xnjUVLPiqPjthH_Tp3Q" changeDate="2008-08-04T14:13:21.234-0700" version="7.5.0">
  <mainDescription>&lt;table bordercolor=&quot;#ffffff&quot; height=&quot;330&quot; width=&quot;100%&quot; border=&quot;1&quot;>&#xD;
    &lt;tbody>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;23%&quot; height=&quot;340&quot;>&#xD;
                &lt;p dir=&quot;ltr&quot; align=&quot;left&quot;>&#xD;
                    Complexity is a central issue in software development. Elevating the level of abstraction helps reduce&#xD;
                    complexity as well the amount of documentation required by the project. This can be achieved through&#xD;
                    reuse, the use of high-level modeling tools, and stabilizing the architecture early.&#xD;
                &lt;/p>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;4%&quot; height=&quot;340&quot;>&#xD;
                &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;73%&quot;>&#xD;
                &lt;table bordercolor=&quot;#000000&quot; height=&quot;310&quot; cellpadding=&quot;10&quot; width=&quot;99%&quot; border=&quot;3&quot;>&#xD;
                    &lt;tbody>&#xD;
                        &lt;tr>&#xD;
                            &lt;td width=&quot;16%&quot; height=&quot;60&quot;>&#xD;
                                &lt;strong>Benefits&lt;/strong>&#xD;
                            &lt;/td>&#xD;
                            &lt;td width=&quot;84%&quot;>&#xD;
                                &lt;ul>&#xD;
                                    &lt;li>&#xD;
                                        Productivity&#xD;
                                    &lt;/li>&#xD;
                                    &lt;li>&#xD;
                                        Reduced complexity.&#xD;
                                    &lt;/li>&#xD;
                                &lt;/ul>&#xD;
                            &lt;/td>&#xD;
                        &lt;/tr>&#xD;
                        &lt;tr>&#xD;
                            &lt;td height=&quot;98&quot;>&#xD;
                                &lt;strong>Pattern&lt;/strong>&#xD;
                            &lt;/td>&#xD;
                            &lt;td>&#xD;
                                &lt;ol>&#xD;
                                    &lt;li>&#xD;
                                        Reuse existing assets&#xD;
                                    &lt;/li>&#xD;
                                    &lt;li>&#xD;
                                        Use higher-level tools and languages to reduce the amount of documentation produced&#xD;
                                    &lt;/li>&#xD;
                                    &lt;li>&#xD;
                                        Focus on architecture first&#xD;
                                    &lt;/li>&#xD;
                                    &lt;li>&#xD;
                                        Architect for resilience, quality, understandability, complexity control.&#xD;
                                    &lt;/li>&#xD;
                                &lt;/ol>&#xD;
                            &lt;/td>&#xD;
                        &lt;/tr>&#xD;
                        &lt;tr>&#xD;
                            &lt;td height=&quot;136&quot;>&#xD;
                                &lt;strong>Anti-Patterns&lt;/strong>&#xD;
                            &lt;/td>&#xD;
                            &lt;td>&#xD;
                                &lt;ul>&#xD;
                                    &lt;li>&#xD;
                                        To go directly from vague, high-level requirements to custom-crafted code: &#xD;
                                        &lt;ul>&#xD;
                                            &lt;li>&#xD;
                                                Since few abstractions are used, a lot of the discussions are made at the&#xD;
                                                code level versus a more conceptual level, which misses many opportunities&#xD;
                                                for reuse, among other things.&#xD;
                                            &lt;/li>&#xD;
                                            &lt;li>&#xD;
                                                Informally captured requirements and other information require decisions&#xD;
                                                and specifications to be revisited repeatedly&#xD;
                                            &lt;/li>&#xD;
                                            &lt;li>&#xD;
                                                Limited emphasis on architecture causes major rework late in the project.&#xD;
                                            &lt;/li>&#xD;
                                        &lt;/ul>&#xD;
                                    &lt;/li>&#xD;
                                &lt;/ul>&#xD;
                            &lt;/td>&#xD;
                        &lt;/tr>&#xD;
                    &lt;/tbody>&#xD;
                &lt;/table>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/tbody>&#xD;
&lt;/table>&#xD;
&lt;h4>&#xD;
    Discussion&amp;nbsp;&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    One of the main problems we face in software development is complexity. We know that reducing complexity has a major&#xD;
    impact on productivity. Working at a higher level of abstraction reduces complexity and facilitates communication.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    One effective approach to reducing complexity is &lt;em>reusing existing assets&lt;/em>, such as reusable components, legacy&#xD;
    systems, existing business processes, patterns, or open source software. Two great examples of reuse that have had a&#xD;
    major impact on the software industry over the last decade&amp;nbsp;are:&#xD;
&lt;/p>&#xD;
&lt;div style=&quot;MARGIN-LEFT: 2em&quot;>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            The reuse of middleware, such as databases, web servers and portals, and, more recently,&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Open source software that provides many smaller and larger components that can be leveraged.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Moving forward, Web services will likely have a major impact on reuse, since they provide simple ways of reusing major&#xD;
    chunks of functionality across disparate platforms and with loose coupling between the consumer and provider of a&#xD;
    service. This means that we can more easily leverage different combinations of services to address business needs.&#xD;
    Reuse is also facilitated by open standards, such as RAS, UDDI, SOAP, WSDL, XML, and UML.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img alt=&quot;Diagram illustrating reuse existing assets through service-oriented architectures&quot;     src=&quot;./resources/bp_fig5.gif&quot; />&lt;br />&#xD;
    &lt;strong>Reuse existing assets through service-oriented architectures.&lt;/strong>&lt;br />&#xD;
    &lt;em>One of the problems with reuse is that two components need to know about each others existence at development time.&#xD;
    Service-oriented architectures alleviate that problem by providing what is called loose coupling: A&amp;nbsp;consumer of a&#xD;
    service can dynamically find a provider of a service. We can therefore wrap existing components or legacy systems into&#xD;
    services, allowing other components or applications to dynamically get access to their capabilities through a&#xD;
    standards-based interface, independent of platform and implementation technology&lt;/em>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another approach to reducing complexity and improving communication consists of &lt;em>leveraging higher-level tools,&#xD;
    frameworks, and languages:&lt;/em>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;strong>Standard languages&lt;/strong> such as Unified Modeling Language (UML) and rapid application languages such as&#xD;
        EGL provide the ability to express high-level constructs, such as business processes and service&#xD;
        components,&amp;nbsp;which facilitates collaboration around high-level constructs while hiding unnecessary details.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Design and construction tools&lt;/strong> can automate moving from high-level constructs to working code:&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                They provide wizards&amp;nbsp;that&amp;nbsp;automate design, construction, and test tasks by generating code and&#xD;
                enabling usage of code snippets,&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                They&amp;nbsp;convert integration and testing into seamless development tasks through integrated development,&#xD;
                build, and test environments.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;strong>Portfolio management tools,&lt;/strong> which enables managing &amp;nbsp;financial and other aspects of multiple&#xD;
        projects as one entity versus as a set of separate entities.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In short, high level tools capture key modeling information graphically, which is a powerful and attractive way to&#xD;
    summarize and present this information. The benefits of visual modeling are explored in more details in Supporting&#xD;
    Material: Visual Modeling.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A third approach to managing complexity is to &lt;em>focus on architecture&lt;/em>, either to define a business, or develop a&#xD;
    system or application. In software development, we aim at getting the architecture designed, implemented, and tested&#xD;
    early in the project. This means that, early in the project, we focus on the following goals:&lt;!--EndFragment-->&#xD;
&lt;/p>&#xD;
&lt;div style=&quot;MARGIN-LEFT: 2em&quot;>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Defining the high-level building blocks and the most important components, their responsibilities, and their&#xD;
            interfaces.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Designing and implement the architectural mechanisms, that is, ready-made solutions to common problems, such as&#xD;
            how to deal with persistency or garbage collection.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    By getting the architecture right early-on, we provide a skeleton structure for our system, making it easier to manage&#xD;
    complexity as we add more people, components, capabilities, and code to the project. We also identify what reusable&#xD;
    assets we can leverage, and what aspects of the system needs to be custom built.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
